<!DOCTYPE HTML>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta name="generator" content="Jekyll v4.2.0">
  <link type="application/atom+xml" rel="alternate" href="../../feed.xml" title="Frida • A world-class dynamic instrumentation toolkit" />
  <link rel="alternate" type="application/atom+xml" title="Recent commits to Frida’s master branch" href="https://github.com/frida/frida/commits/master.atom" />
  <link rel="stylesheet" href="../../css/screen.css" />
  <link rel="icon" type="image/png" href="../../favicon.ico" />
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Stalker | Frida • A world-class dynamic instrumentation toolkit</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Stalker" />
<meta property="og:locale" content="en" />
<meta name="description" content="Observe and reprogram running programs on Windows, macOS, GNU/Linux, iOS, watchOS, tvOS, Android, FreeBSD, and QNX" />
<meta property="og:description" content="Observe and reprogram running programs on Windows, macOS, GNU/Linux, iOS, watchOS, tvOS, Android, FreeBSD, and QNX" />
<link rel="canonical" href="index.html" />
<meta property="og:url" content="https://frida.re/docs/stalker/" />
<meta property="og:site_name" content="Frida • A world-class dynamic instrumentation toolkit" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-25T09:11:28+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Stalker" />
<meta name="twitter:site" content="@fridadotre" />
<script type="application/ld+json">
{"headline":"Stalker","dateModified":"2023-12-25T09:11:28+01:00","datePublished":"2023-12-25T09:11:28+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://frida.re/docs/stalker/"},"@type":"BlogPosting","description":"Observe and reprogram running programs on Windows, macOS, GNU/Linux, iOS, watchOS, tvOS, Android, FreeBSD, and QNX","url":"https://frida.re/docs/stalker/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <script src="../../js/modernizr-2.5.3.min.js"></script>
</head>


<body class="wrap">
  <header>
  <nav class="mobile-nav show-on-mobiles">
    <ul>
  <li class="">
    <a href="../../index.html">Overview</a>
  </li>
  <li class="current">
    <a href="../home/index.html">Docs</span></a>
  </li>
  <li class="">
    <a href="../../news/index.html">News</a>
  </li>
  <li class="">
    <a href="https://github.com/frida/frida">Code</a>
  </li>
  <li class="">
    <a href="../../contact/index.html">Contact</a>
  </li>
</ul>

  </nav>
  <div class="grid">
    <div class="logotype unit one-third center-on-mobiles">
      <a href="../../index.html">
        <span>FЯIDA</span>
        <img src="../../img/logotype.svg" width="205" height="39" alt="">
      </a>
    </div>
    <nav class="main-nav unit two-thirds hide-on-mobiles">
      <ul>
  <li class="">
    <a href="../../index.html">Overview</a>
  </li>
  <li class="current">
    <a href="../home/index.html">Docs</span></a>
  </li>
  <li class="">
    <a href="../../news/index.html">News</a>
  </li>
  <li class="">
    <a href="https://github.com/frida/frida">Code</a>
  </li>
  <li class="">
    <a href="../../contact/index.html">Contact</a>
  </li>
</ul>

    </nav>
  </div>
</header>


    <section class="docs">
    <div class="grid">

      <div class="docs-nav-mobile unit whole show-on-mobiles">
  <select onchange="if (this.value) window.location.href=this.value">
    <option value="">Navigate the docs…</option>
    
    <optgroup label="Getting Started">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/home/">Welcome</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/quickstart/">Quick-start guide</option>
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/installation/">Installation</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/modes/">Modes of Operation</option>
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/gadget/">Gadget</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/hacking/">Hacking</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/stalker/">Stalker</option>
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/presentations/">Presentations</option>
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="Tutorials">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/functions/">Functions</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/messages/">Messages</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/ios/">iOS</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
      <option value="/docs/android/">Android</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="Examples">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/windows/">Windows</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/macos/">macOS</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/linux/">Linux</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/ios/">iOS</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/android/">Android</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/examples/javascript/">JavaScript</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="Tools">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-cli/">Frida CLI</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-ps/">frida-ps</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-trace/">frida-trace</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-discover/">frida-discover</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-ls-devices/">frida-ls-devices</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/frida-kill/">frida-kill</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/gum-graft/">gum-graft</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="API Reference">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/javascript-api/">JavaScript API</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
      <option value="/docs/c-api/">C API</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/swift-api/">Swift API</option>
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/go-api/">Go API</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="Miscellaneous">
      


  

  
    
  
    
      <option value="/docs/best-practices/">Best Practices</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/troubleshooting/">Troubleshooting</option>
    
  

  

  
    
  
    
  
    
      <option value="/docs/building/">Building</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/footprint/">Footprint</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
    <optgroup label="Meta">
      


  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/gsoc-ideas-2015/">GSoC Ideas 2015</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/gsod-ideas-2023/">GSoD Ideas 2023</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  

  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <option value="/docs/history/">History</option>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  


    </optgroup>
    
  </select>
</div>

      <div class="docs-nav-desktop unit one-quarter hide-on-mobiles">
  <aside>
    
    <h4>Getting Started</h4>
    

<ul>

  

  

  
  <li class=""><a href="../home/index.html">Welcome</a></li>


  

  

  
  <li class=""><a href="../quickstart/index.html">Quick-start guide</a></li>


  

  

  
  <li class=""><a href="../installation/index.html">Installation</a></li>


  

  

  
  <li class=""><a href="../modes/index.html">Modes of Operation</a></li>


  

  

  
  <li class=""><a href="../gadget/index.html">Gadget</a></li>


  

  

  
  <li class=""><a href="../hacking/index.html">Hacking</a></li>


  

  

  
  <li class="current"><a href="index.html">Stalker</a></li>


  

  

  
  <li class=""><a href="../presentations/index.html">Presentations</a></li>


</ul>

    
    <h4>Tutorials</h4>
    

<ul>

  

  

  
  <li class=""><a href="../functions/index.html">Functions</a></li>


  

  

  
  <li class=""><a href="../messages/index.html">Messages</a></li>


  

  

  
  <li class=""><a href="../ios/index.html">iOS</a></li>


  

  

  
  <li class=""><a href="../android/index.html">Android</a></li>


</ul>

    
    <h4>Examples</h4>
    

<ul>

  

  

  
  <li class=""><a href="../examples/windows/index.html">Windows</a></li>


  

  

  
  <li class=""><a href="../examples/macos/index.html">macOS</a></li>


  

  

  
  <li class=""><a href="../examples/linux/index.html">Linux</a></li>


  

  

  
  <li class=""><a href="../examples/ios/index.html">iOS</a></li>


  

  

  
  <li class=""><a href="../examples/android/index.html">Android</a></li>


  

  

  
  <li class=""><a href="../examples/javascript/index.html">JavaScript</a></li>


</ul>

    
    <h4>Tools</h4>
    

<ul>

  

  

  
  <li class=""><a href="../frida-cli/index.html">Frida CLI</a></li>


  

  

  
  <li class=""><a href="../frida-ps/index.html">frida-ps</a></li>


  

  

  
  <li class=""><a href="../frida-trace/index.html">frida-trace</a></li>


  

  

  
  <li class=""><a href="../frida-discover/index.html">frida-discover</a></li>


  

  

  
  <li class=""><a href="../frida-ls-devices/index.html">frida-ls-devices</a></li>


  

  

  
  <li class=""><a href="../frida-kill/index.html">frida-kill</a></li>


  

  

  
  <li class=""><a href="../gum-graft/index.html">gum-graft</a></li>


</ul>

    
    <h4>API Reference</h4>
    

<ul>

  

  

  
  <li class=""><a href="../javascript-api/index.html">JavaScript API</a></li>


  

  

  
  <li class=""><a href="../c-api/index.html">C API</a></li>


  

  

  
  <li class=""><a href="../swift-api/index.html">Swift API</a></li>


  

  

  
  <li class=""><a href="../go-api/index.html">Go API</a></li>


</ul>

    
    <h4>Miscellaneous</h4>
    

<ul>

  

  

  
  <li class=""><a href="../best-practices/index.html">Best Practices</a></li>


  

  

  
  <li class=""><a href="../troubleshooting/index.html">Troubleshooting</a></li>


  

  

  
  <li class=""><a href="../building/index.html">Building</a></li>


  

  

  
  <li class=""><a href="../footprint/index.html">Footprint</a></li>


</ul>

    
    <h4>Meta</h4>
    

<ul>

  

  

  
  <li class=""><a href="index.html"></a></li>


  

  

  
  <li class=""><a href="../gsoc-ideas-2015/index.html">GSoC Ideas 2015</a></li>


  

  

  
  <li class=""><a href="../gsod-ideas-2023/index.html">GSoD Ideas 2023</a></li>


  

  

  
  <li class=""><a href="../history/index.html">History</a></li>


</ul>

    
  </aside>
</div>


      <div class="docs-articles unit three-quarters">
        <article>
          <div class="improve right hide-on-mobiles">
            <a href="https://github.com/frida/frida-website/edit/main/_i18n/en/_docs/stalker.md">
              <i class="fa fa-pencil"></i>Improve this page</a>
          </div>
          <h1>Stalker</h1>
          <h2 id="introduction">Introduction</h2>

<p>Stalker is Frida’s code tracing engine. It allows threads to be followed,
capturing every function, every block, even every instruction which is executed.
A very good overview of the Stalker engine is provided
<a href="https://medium.com/@oleavr/anatomy-of-a-code-tracer-b081aadb0df8">here</a> and we
recommend that you read it carefully first. Obviously, the implementation is
somewhat architecture specific, although there is much in common between them.
Stalker currently supports the AArch64 architecture commonly found on mobile
phones and tablets running Android or iOS, as well as the Intel 64 and IA-32
architectures commonly found on desktops and laptops. This page intends to take
things to the next level of detail, it dissects the ARM64 implementation of
Stalker and explains in more detail exactly how it works. It is hoped that this
may help future efforts to port Stalker to other hardware architectures.</p>

<h2 id="disclaimer">Disclaimer</h2>

<p>Whilst this article will cover a lot of the details of the inner workings of
Stalker, it won’t cover back-patching in real detail. It is intended as a
starting point to help others understand the technology and Stalker is
fiendishly complicated enough without this! To be fair though, this complexity
isn’t there without reason, it is there to minimize the overhead of what is an
inherently expensive operation. Lastly, while this article will cover the key
concepts of the implementation and will extract some critical parts of the
implementation for a line-by-line analysis, there will be some last details of
the implementation left for the reader to discover by reading the <a href="https://github.com/frida/frida-gum/blob/master/gum/backend-arm64/gumstalker-arm64.c">source
code</a>.
However, it is hoped it will prove to be a very useful head-start.</p>

<h2 id="table-of-contents">Table of contents</h2>

<ol>
  <li><a href="index.html#introduction">Introduction</a></li>
  <li><a href="index.html#disclaimer">Disclaimer</a></li>
  <li><a href="index.html#use-cases">Use Cases</a></li>
  <li><a href="index.html#following">Following</a>
    <ol>
      <li><a href="index.html#gum_stalker_follow_me">gum_stalker_follow_me</a></li>
      <li><a href="index.html#gum_stalker_follow">gum_stalker_follow</a></li>
    </ol>
  </li>
  <li><a href="index.html#basic-operation">Basic Operation</a></li>
  <li><a href="index.html#options">Options</a></li>
  <li><a href="index.html#terminology">Terminology</a>
    <ol>
      <li><a href="index.html#probes">Probes</a></li>
      <li><a href="index.html#trust-threshold">Trust Threshold</a></li>
      <li><a href="index.html#excluded-ranges">Excluded Ranges</a></li>
      <li><a href="index.html#freezethaw">Freeze/Thaw</a></li>
      <li><a href="index.html#call-instructions">Call Instructions</a></li>
      <li><a href="index.html#frames">Frames</a></li>
      <li><a href="index.html#transformer">Transformer</a></li>
      <li><a href="index.html#callouts">Callouts</a></li>
      <li><a href="index.html#eobeoi">EOB/EOI</a></li>
      <li><a href="index.html#prologuesepilogues">Prologues/Epilogues</a></li>
      <li><a href="index.html#counters">Counters</a></li>
    </ol>
  </li>
  <li><a href="index.html#slabs">Slabs</a></li>
  <li><a href="index.html#blocks">Blocks</a></li>
  <li><a href="index.html#instrumenting-blocks">Instrumenting Blocks</a></li>
  <li><a href="index.html#helpers">Helpers</a>
    <ol>
      <li><a href="index.html#last_stack_push">last_stack_push</a></li>
      <li><a href="index.html#last_stack_pop_and_go">last_stack_pop_and_go</a></li>
    </ol>
  </li>
  <li><a href="index.html#context">Context</a></li>
  <li><a href="index.html#context-helpers">Context Helpers</a></li>
  <li><a href="index.html#readingwriting-context">Reading/Writing Context</a></li>
  <li><a href="index.html#control-flow">Control flow</a></li>
  <li><a href="index.html#gates">Gates</a></li>
  <li><a href="index.html#virtualize-functions">Virtualize functions</a>
    <ol>
      <li><a href="index.html#gum_exec_block_virtualize_branch_insn">gum_exec_block_virtualize_branch_insn</a></li>
      <li><a href="index.html#gum_exec_block_virtualize_ret_insn">gum_exec_block_virtualize_ret_insn</a></li>
    </ol>
  </li>
  <li><a href="index.html#emitting-events">Emitting events</a></li>
  <li><a href="index.html#unfollow-and-tidy-up">Unfollow and tidy up</a></li>
  <li><a href="index.html#miscellaneous">Miscellaneous</a>
    <ol>
      <li><a href="index.html#exclusive-store">Exclusive Store</a></li>
      <li><a href="index.html#exhausted-blocks">Exhausted Blocks</a></li>
      <li><a href="index.html#syscall-virtualization">Syscall Virtualization</a></li>
      <li><a href="index.html#pointer-authentication">Pointer Authentication</a></li>
    </ol>
  </li>
</ol>

<h2 id="use-cases">Use Cases</h2>

<p>To start to understand the implementation of Stalker, we must first understand
in detail what it offers to the user. Whilst Stalker can be invoked directly
through its native Gum interface, most users will instead call it via the
<a href="../javascript-api/index.html#stalker">JavaScript API</a> which will call
these Gum methods on their behalf. The <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/frida-gum/index.d.ts">TypeScript type
definitions</a>
for Gum are well commented and provide a little more detail still.</p>

<p>The main API to Stalker from JavaScript is:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">Stalker</span><span class="p">.</span><span class="nx">follow</span><span class="p">([</span><span class="nx">threadId</span><span class="p">,</span> <span class="nx">options</span><span class="p">])</span></code></pre></figure>

<blockquote>
  <p>start stalking <code class="language-plaintext highlighter-rouge">threadId</code> (or the current thread if omitted)</p>
</blockquote>

<p>Let’s consider when these calls may be used. Stalking where you provide a thread
ID is likely to be used where you have a thread of interest and are wondering
what it is doing. Perhaps it has an interesting name? Thread names can be found
using <code class="language-plaintext highlighter-rouge">cat /proc/PID/tasks/TID/comm</code>. Or perhaps you walked the threads in your
process using the Frida JavaScript API <code class="language-plaintext highlighter-rouge">Process.enumerateThreads()</code> and then
used a NativeFunction to call:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_getname_np</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span>
                       <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span></code></pre></figure>

<p>Using this along with the
<a href="../javascript-api/index.html#thread">Thread.backtrace()</a> to dump
thread stacks can give you a really good overview of what a process is doing.</p>

<p>The other scenario where you might call <code class="language-plaintext highlighter-rouge">Stalker.follow()</code> is perhaps from a
function which has been
<a href="../javascript-api/index.html#interceptor">intercepted</a> or replaced. In
this scenario, you have found a function of interest and you want to understand
how it behaves, you want to see which functions or perhaps even code blocks the
thread takes after a given function is called. Perhaps you want to compare the
direction the code takes with different input, or perhaps you want to modify the
input to see if you can get the code to take a particular path.</p>

<p>In either of these scenarios, although Stalker has to work slightly differently
under the hood, it is all managed by the same simple API for the user,
<code class="language-plaintext highlighter-rouge">Stalker.follow()</code>.</p>

<h2 id="following">Following</h2>

<p>When the user calls <code class="language-plaintext highlighter-rouge">Stalker.follow()</code>, under the hood, the JavaScript engine
calls through to either <code class="language-plaintext highlighter-rouge">gum_stalker_follow_me()</code> to follow the current thread,
or <code class="language-plaintext highlighter-rouge">gum_stalker_follow(thread_id)</code> to follow another thread in the process.</p>

<h3 id="gum_stalker_follow_me">gum_stalker_follow_me</h3>

<p>In the case of <code class="language-plaintext highlighter-rouge">gum_stalker_follow_me()</code>, the Link Register is used to determine
the instruction at which to start stalking. In AArch64 architecture, the Link
Register (LR) is set to the address of the instruction to continue execution
following the return from a function call, it is set to the address of the next
instruction by instructions such as BL and BLR. As there is only one link
register, if the called function is to call another routine, then the value of
LR must be stored (typically this will be on the stack). This value will
subsequently be loaded back from the stack into a register and the RET
instruction used to return control back to the caller.</p>

<p>Let’s look at the code for <code class="language-plaintext highlighter-rouge">gum_stalker_follow_me()</code>. This is the function
prototype:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">GUM_API</span> <span class="kt">void</span> <span class="nf">gum_stalker_follow_me</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
    <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">GumEventSink</span> <span class="o">*</span> <span class="n">sink</span><span class="p">);</span></code></pre></figure>

<p>So we can see the function is called by the QuickJS or V8 runtime passing 3
arguments. The first is the Stalker instance itself. Note that there may be
multiple of these if multiple scripts are loaded at once. The second is a
transformer, this can be used to transform the instrumented code as it is being
written (more on this later). The last parameter is the event sink, this is
where the generated events are passed as the Stalker engine runs.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">#ifdef __APPLE__
  .globl _gum_stalker_follow_me
_gum_stalker_follow_me:
#else
  .globl gum_stalker_follow_me
  .type gum_stalker_follow_me, %function
gum_stalker_follow_me:
#endif
  stp x29, x30, [sp, -16]!
  mov x29, sp
  mov x3, x30
#ifdef __APPLE__
  bl __gum_stalker_do_follow_me
#else
  bl _gum_stalker_do_follow_me
#endif
  ldp x29, x30, [sp], 16
  br x0</code></pre></figure>

<p>We can see that the first instruction STP stores a pair of registers onto the
stack. We can notice the expression <code class="language-plaintext highlighter-rouge">[sp, -16]!</code>. This is a
<a href="https://thinkingeek.com/2017/05/29/exploring-aarch64-assembler-chapter-8/">pre-decrement</a>
which means that the stack is advanced first by 16 bytes, then the two 8 byte
register values are stored. We can see the corresponding instruction
<code class="language-plaintext highlighter-rouge">ldp x29, x30, [sp], 16</code> at the bottom of the function. This is restoring these
two register values from the stack back into the registers. But what are these
two registers?</p>

<p>Well, <code class="language-plaintext highlighter-rouge">X30</code> is the Link Register and <code class="language-plaintext highlighter-rouge">X29</code> is the Frame Pointer register. Recall
that we must store the link register to the stack if we wish to call another
function as this will cause it to be overwritten and we need this value in order
that we can return to our caller.</p>

<p>The frame pointer is used to point to the top of the stack at the point a
function was called so that all the stack passed arguments and the stack based
local variables can be access at a fixed offset from the frame pointer. Again we
need to save and restore this as each function will have its value for this
register, so we need to store the value which our caller put in there and
restore it before we return. Indeed you can see in the next instruction
<code class="language-plaintext highlighter-rouge">mov x29, sp</code> that we set the frame pointer to the current stack pointer.</p>

<p>We can see the next instruction <code class="language-plaintext highlighter-rouge">mov x3, x30</code>, puts the value of the link
register into X3. The first 8 arguments on AArch64 are passed in the registers
X0-X7. So this is being put into the register used for the fourth argument. We
then call (branch with link) the function <code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code>. So we
can see that we pass the first three arguments in X0-X2 untouched, so that
<code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code> receives the same values we were called with.
Finally, we can see after this function returns, we branch to the address we
receive as its return value. (In AArch64 the return value of a function is
returned in X0).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">gpointer</span>
<span class="n">_gum_stalker_do_follow_me</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                           <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span>
                           <span class="n">GumEventSink</span> <span class="o">*</span> <span class="n">sink</span><span class="p">,</span>
                           <span class="n">gpointer</span> <span class="n">ret_addr</span><span class="p">)</span></code></pre></figure>

<h3 id="gum_stalker_follow">gum_stalker_follow</h3>

<p>This routine has a very similar prototype to <code class="language-plaintext highlighter-rouge">gum_stalker_follow_me()</code>, but has
the additional <code class="language-plaintext highlighter-rouge">thread_id</code> parameter. Indeed, if asked to follow the current
thread, then it will call that function. Let’s look at the case when another
thread ID is specified though.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">gum_stalker_follow</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                    <span class="n">GumThreadId</span> <span class="n">thread_id</span><span class="p">,</span>
                    <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span>
                    <span class="n">GumEventSink</span> <span class="o">*</span> <span class="n">sink</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">thread_id</span> <span class="o">==</span> <span class="n">gum_process_get_current_thread_id</span> <span class="p">())</span>
  <span class="p">{</span>
    <span class="n">gum_stalker_follow_me</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">sink</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">GumInfectContext</span> <span class="n">ctx</span><span class="p">;</span>

    <span class="n">ctx</span><span class="p">.</span><span class="n">stalker</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">transformer</span><span class="p">;</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">sink</span><span class="p">;</span>

    <span class="n">gum_process_modify_thread</span> <span class="p">(</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">gum_stalker_infect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We can see that this calls the function <code class="language-plaintext highlighter-rouge">gum_process_modify_thread()</code>. This
isn’t part of Stalker, but part of Gum itself. This function takes a callback
with a context parameter to call passing the thread context structure. This
callback can then modify the <code class="language-plaintext highlighter-rouge">GumCpuContext</code> structure and
<code class="language-plaintext highlighter-rouge">gum_process_modify_thread()</code> will then write the changes back. We can see the
context structure below, as you can see it contains fields for all of the
registers in the AArch64 CPU. We can also see below the function prototype of
our callback.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">GumArm64CpuContext</span> <span class="n">GumCpuContext</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumArm64CpuContext</span>
<span class="p">{</span>
  <span class="n">guint64</span> <span class="n">pc</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">sp</span><span class="p">;</span>

  <span class="n">guint64</span> <span class="n">x</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
  <span class="n">guint64</span> <span class="n">fp</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">lr</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="n">q</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="p">};</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="n">gum_stalker_infect</span> <span class="p">(</span><span class="n">GumThreadId</span> <span class="n">thread_id</span><span class="p">,</span>
                    <span class="n">GumCpuContext</span> <span class="o">*</span> <span class="n">cpu_context</span><span class="p">,</span>
                    <span class="n">gpointer</span> <span class="n">user_data</span><span class="p">)</span></code></pre></figure>

<p>So, how does <code class="language-plaintext highlighter-rouge">gum_process_modify_thread()</code> work? Well it depends on the
platform. On Linux (and Android) it uses the <code class="language-plaintext highlighter-rouge">ptrace</code> API (the same one used by
GDB) to attach to the thread and read and write registers. But there are a host
of complexities. On Linux, you cannot ptrace your own process (or indeed any in
the same process group), so Frida creates a clone of the current process in its
own process group and shares the same memory space. It communicates with it
using a UNIX socket. This cloned process acts as a debugger, reading the
registers of the original target process and storing them in the shared memory
space and then writing them back to the process on demand. Oh and then there is
<code class="language-plaintext highlighter-rouge">PR_SET_DUMPABLE</code> and <code class="language-plaintext highlighter-rouge">PR_SET_PTRACER</code> which control the permissions of who is
allowed to ptrace our original process.</p>

<p>Now you will see that the functionality of <code class="language-plaintext highlighter-rouge">gum_stalker_infect()</code> is actually
quite similar to that of <code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code> we mentioned earlier.
Both function carry out essentially the same job, although
<code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code> is running on the target thread, but
<code class="language-plaintext highlighter-rouge">gum_stalker_infect()</code> is not, so it must write some code to be called by the
target thread using the
<a href="https://github.com/frida/frida-gum/blob/master/gum/arch-arm64/gumarm64writer.c">GumArm64Writer</a>
rather than calling functions directly.</p>

<p>We will cover these functions in more detail shortly, but first we need a little
more background.</p>

<h2 id="basic-operation">Basic Operation</h2>

<p>Code can be thought of as a series of blocks of instructions (also known as
basic blocks). Each block starts with an optional series of instructions (we may
have two consecutive branch statements) which run in sequence and ends when we
encounter an instruction which causes (or can cause) execution to continue with
an instruction other than the one immediately following it in memory.</p>

<p>Stalker works on one block at a time. It starts with either the block after the
return to the call to <code class="language-plaintext highlighter-rouge">gum_stalker_follow_me()</code> or the block of code to which
the instruction pointer of the target thread is pointing when
<code class="language-plaintext highlighter-rouge">gum_stalker_follow()</code> is called.</p>

<p>Stalker works by allocating some memory and writing to it a new instrumented
copy of the original block. Instructions may be added to generate events, or
carry out any of the other features the Stalker engine offers. Stalker must also
relocate instructions as necessary. Consider the following instruction:</p>

<blockquote>
  <p>ADR
Address of label at a PC-relative offset.</p>

  <p>ADR  Xd, label</p>

  <p>Xd
Is the 64-bit name of the general-purpose destination
register, in the range 0 to 31.</p>

  <p>label
Is the program label whose address is to be calculated.
It is an offset from the address of this instruction,
in the range ±1MB.</p>
</blockquote>

<p>If this instruction is copied to a different location in memory and executed,
then because the address of the label is calculated by adding an offset to the
current instruction pointer, then the value would be different. Fortunately, Gum
has a
<a href="https://github.com/frida/frida-gum/blob/master/gum/arch-arm64/gumarm64relocator.c">Relocator</a>
for just this purpose which is capable of modifying the instruction given its
new location so that the correct address is calculated.</p>

<p>Now, recall we said that Stalker works one block at a time. How, then do we
instrument the next block? We remember also that each block also ends with a
branch instruction, well if we modify this branch to instead branch back into
the Stalker engine, but ensure we store the destination of where the branch was
intending to end up, we can instrument the next block and re-direct execution
there instead. This same simple process can continue with one block after the
next.</p>

<p>Now, this process can be a little slow, so there are a few optimizations which
we can apply. First of all, if we execute the same block of code more than once
(e.g. a loop, or maybe just a function called multiple times) we don’t have to
re-instrument it all over again. We can just re-execute the same instrumented
code. For this reason, a hashtable is kept of all of the blocks which we have
encountered before and where we put the instrumented copy of the block.</p>

<p>Secondly, when a call instruction is encountered, after emitting the
instrumented call, we then emit a landing pad which we can return to without
having to re-enter Stalker. Stalker builds a side-stack, using <code class="language-plaintext highlighter-rouge">GumExecFrame</code>
structures which record the true return address (<code class="language-plaintext highlighter-rouge">real_address</code>) and this
landing pad (<code class="language-plaintext highlighter-rouge">code_address</code>). When a function returns, we emit code that will
check the return address in the side-stack against the <code class="language-plaintext highlighter-rouge">real_address</code> and if it
matches, it can simply return to the <code class="language-plaintext highlighter-rouge">code_address</code> without re-entering the
runtime. This landing pad initially will contain code which enters the Stalker
engine to instrument the next block, but it can later be backpatched to branch
directly to this block. This means that the entire return sequence can be
handled without the expense of entering and leaving Stalker.</p>

<p>If the return address doesn’t match that stored the <code class="language-plaintext highlighter-rouge">real_address</code> of the
<code class="language-plaintext highlighter-rouge">GumExecFrame</code>, or we run out of space in the side-stack, we simply start
building a new one again from scratch. We need to preserve the value of LR
whilst the application code is executing so that the application cannot use this
to detect the presence of Stalker (anti-debugging) or in case it is using it for
any other purpose besides simply returning (e.g. to reference inline data in the
code section). Also, we want Stalker to be able to unfollow at any time, so we
don’t want to be having to go back up our stack correcting LR values which we
have modified along the way.</p>

<p>Finally, whilst we always replace branches with calls back to Stalker to
instrument the next block, depending on the configuration of
<code class="language-plaintext highlighter-rouge">Stalker.trustThreshold</code>, we may <em>backpatch</em> such instrumented code to replace
the call with a direct branch to the next instrumented block instead.
Deterministic branches (e.g. the destination is fixed and the branch is not
conditional) are simple, we can just replace the branch to Stalker with one to
the next block. But we can deal with conditional branches too, if we instrument
both blocks of code (the one if the branch is taken and the one if it isn’t).
Then we can replace the original conditional branch with one conditional branch
which directs control flow to instrumented version of the block encountered when
the branch was taken, followed by an unconditional branch to the other
instrumented block. We can also deal partially with branches where the target is
not static. Say our branch is something like:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">br x0</code></pre></figure>

<p>This sort of instruction is common when calling a function pointer, or class
method. Whilst the value of X0 can change, quite often it will actually always
be the same. In this case, we can replace the final branch instruction with code
which compares the value of X0 against our known function, and if it matches
branches to the address of the instrumented copy of the code. This can then be
followed by an unconditional branch back to the Stalker engine if it doesn’t
match. So if the value of the function pointer say is changed, then the code
will still work and we will re-enter Stalker and instrument wherever we end up.
However, if as we expect it remains unchanged then we can bypass the Stalker
engine altogether and go straight to the instrumented function.</p>

<h2 id="options">Options</h2>

<p>Now let’s look at the options when we follow a thread with Stalker. Stalker
generates events when a followed thread is being executed, these are placed onto
a queue and flushed either periodically or manually by the user. This isn’t done
by Stalker itself, but the <code class="language-plaintext highlighter-rouge">EventSink::process</code> vfunc as re-entering the
JavaScript runtime to process events one at a time would be prohibitively
expensive. The size and time period can be configured by the options. Events can
be generated on a per-instruction basis either for calls, returns or all
instructions. Or they can be generated on a block basis, either when a block is
executed, or when it is instrumented by the Stalker engine.</p>

<p>We can also provide one of two callbacks <code class="language-plaintext highlighter-rouge">onReceive</code> or <code class="language-plaintext highlighter-rouge">onCallSummary</code>. The
former will quite simply deliver a binary blob containing the raw events
generated by Stalker, with events in the order that they were generated in.
(<code class="language-plaintext highlighter-rouge">Stalker.parse()</code> can be used to turn it into a JS array of tuples representing
the events.). The second aggregates these results simply returning a count of
times each function was called. This is more efficient than <code class="language-plaintext highlighter-rouge">onReceive</code>, but the
data is much less granular.</p>

<h2 id="terminology">Terminology</h2>

<p>Before we can carry on with describing the detailed implementation of Stalker,
we first need to understand some key terminology and concepts that are used in
the design.</p>

<h3 id="probes">Probes</h3>

<p>Whilst a thread is running outside of Stalker, you may be familiar with using
<code class="language-plaintext highlighter-rouge">Interceptor.attach()</code> to get a callback when a given function is called. When a
thread is running in Stalker, however, these interceptors may not work. These
interceptors work by patching the first few instructions (prologue) of the
target function to re-direct execution into Frida. Frida copies and relocates
these first few instructions somewhere else so that after the <code class="language-plaintext highlighter-rouge">onEnter</code> callback
has been completed, it can re-direct control flow back to the original function.</p>

<p>The reasons these may not work within Stalker is simple, the original function
is never called. Each block, before it is executed is instrumented elsewhere in
memory and it is this copy which is executed. Stalker supports the API function
<code class="language-plaintext highlighter-rouge">Stalker.addCallProbe(address, callback[, data])</code> to provide this functionality
instead. If our <code class="language-plaintext highlighter-rouge">Interceptor</code> has been attached before the block is
instrumented, or Stalker’s <code class="language-plaintext highlighter-rouge">trustThreshold</code> is configured so that our block will
be re-instrumented then our <code class="language-plaintext highlighter-rouge">Interceptor</code> will work (as the patched instructions
will be copied across to the new instrumented block). Otherwise it won’t. Of
course, we want to be able to support hooking functions when these conditions
aren’t met. The average user of the API might not be familiar with this level
of detail of the design and so call probes solve this problem.</p>

<p>The optional data parameter is passed when the probe callback is
registered and will be passed to the callback routine when executed. This
pointer, therefore needs to be stored in the Stalker engine. Also the address
needs to be stored, so that when an instruction is encountered which calls the
function, the code can instead be instrumented to call the function first. As
multiple functions may call the one to which you add the probe, many
instrumented blocks may contain additional instructions to call the probe
function. Thus whenever a probe is added or removed, the cached instrumented
blocks are all destroyed and so all code has to be re-instrumented. Note that
this data parameter is only used if the <code class="language-plaintext highlighter-rouge">callback</code> is a C callback – e.g.
implemented using <code class="language-plaintext highlighter-rouge">CModule</code> – as when JavaScript is used, it is simpler to use
a closure to capture any required state.</p>

<h3 id="trust-threshold">Trust Threshold</h3>

<p>Recall that one of the simple optimizations we apply is that if we attempt to
execute a block more than once, on subsequent occasions, we can simply call the
instrumented block we created last time around? Well, that only works if the
code we are instrumenting hasn’t changed. In the case of self-modifying code
(which is quite often used as an anti-debugging/anti-disassembly technique to
attempt to frustrate analysis of security critical code) the code may change,
and hence the instrumented block cannot be re-used. So, how do we detect if a
block has changed? We simply keep a copy of the original code in the
data-structure along with the instrumented version. Then when we encounter a
block again, we can compare the code we are going to instrument with the version
we instrumented last time and if they match, we can re-use the block. But
performing the comparison every time a block runs may slow things down. So
again, this is an area where Stalker can be customized.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Stalker.trustThreshold</code>: an integer specifying how many times a piece of code
needs to be executed before it is assumed it can be trusted to not mutate.
Specify -1 for no trust (slow), 0 to trust code from the get-go, and N to
trust code after it has been executed N times. Defaults to 1.</p>
</blockquote>

<p>In actual fact, the value of N is the number of times the block needs to be
re-executed and match the previously instrumented block (e.g. be unchanged)
before we stop performing the comparison. Note that the original copy of the
code block is still stored even when the trust threshold is set to <code class="language-plaintext highlighter-rouge">-1</code> or <code class="language-plaintext highlighter-rouge">0</code>.
Whilst it is not actually needed for these values, it has been retained to keep
things simple. In any case, neither of these is the default setting.</p>

<h3 id="excluded-ranges">Excluded Ranges</h3>

<p>Stalker also has the API <code class="language-plaintext highlighter-rouge">Stalker.exclude(range)</code> that’s passed a base and limit
used to prevent Stalker from instrumenting code within these regions. Consider,
for example, your thread calls <code class="language-plaintext highlighter-rouge">malloc()</code> inside <code class="language-plaintext highlighter-rouge">libc</code>. You most likely don’t
care about the inner workings of the heap and this is not only going to slow
down performance, but also generate a whole lot of extraneous events you don’t
care about. One thing to consider, however, is that as soon as a call is made to
an excluded range, stalking of that thread is stopped until it returns. That
means, if that thread were to call a function which is not inside a restricted
range, a callback perhaps, then this would not be captured by Stalker. Just as
this can be used to stop the stalking of a whole library, it can be used to stop
stalking a given function (and its callees) too. This can be particularly useful
if your target application is statically linked. Here, was cannot simply ignore
all calls to <code class="language-plaintext highlighter-rouge">libc</code>, but we can find the symbol for <code class="language-plaintext highlighter-rouge">malloc()</code> using
<code class="language-plaintext highlighter-rouge">Module.enumerateSymbols()</code> and ignore that single function.</p>

<h3 id="freezethaw">Freeze/Thaw</h3>

<p>As an extension to DEP, some systems prevent pages from being marked writable
and executable at the same time. Thus Frida must toggle the page permissions
between writable and executable to write instrumented code, and allow that code
to execute respectively. When pages are executable, they are said to be frozen
(as they cannot be changed) and when they are made writeable again, they are
considered thawed.</p>

<h3 id="call-instructions">Call Instructions</h3>

<p>AArch64, unlike Intel doesn’t have an single explicit <code class="language-plaintext highlighter-rouge">CALL</code> instruction, which
has different forms to cope with all supported scenarios. Instead, it uses a
number of different instructions to offer support for function calls. These
instructions all branch to a given location and update the Link register, <code class="language-plaintext highlighter-rouge">LR</code>,
with the return address:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BL</code></li>
  <li><code class="language-plaintext highlighter-rouge">BLR</code></li>
  <li><code class="language-plaintext highlighter-rouge">BLRAA</code></li>
  <li><code class="language-plaintext highlighter-rouge">BLRAAZ</code></li>
  <li><code class="language-plaintext highlighter-rouge">BLRAB</code></li>
  <li><code class="language-plaintext highlighter-rouge">BLRABZ</code></li>
</ul>

<p>For simplicity, in the remainder of this article, we will refer to this
collection of instructions as “call instructions”.</p>

<h3 id="frames">Frames</h3>

<p>Whenever Stalker encounters a call, it stores the return address and the address
of the instrumented return block forwarder in a structure and adds these to a
stack stored in a data-structure of its own. It uses this as a speculative
optimization, and also as a heuristic to approximate the call depth when
emitting call and return events.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumExecFrame</span> <span class="n">GumExecFrame</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumExecFrame</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="n">real_address</span><span class="p">;</span>
  <span class="n">gpointer</span> <span class="n">code_address</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<h3 id="transformer">Transformer</h3>

<p>A <code class="language-plaintext highlighter-rouge">GumStalkerTransformer</code> type is used to generate the instrumented code. The
implementation of the default transformer looks like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_default_stalker_transformer_transform_block</span> <span class="p">(</span>
    <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span>
    <span class="n">GumStalkerIterator</span> <span class="o">*</span> <span class="n">iterator</span><span class="p">,</span>
    <span class="n">GumStalkerOutput</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">gum_stalker_iterator_next</span> <span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">gum_stalker_iterator_keep</span> <span class="p">(</span><span class="n">iterator</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>It is called by the function responsible for generating instrumented code,
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> and its job is to generate the instrumented
code. We can see that it does this using a loop to process one instruction at a
time. First retrieving an instruction from the iterator, then telling Stalker to
instrument the instruction as is (without modification). These two functions are
implemented inside Stalker itself. The first is responsible for parsing a
<code class="language-plaintext highlighter-rouge">cs_insn</code> and updating the internal state. This <code class="language-plaintext highlighter-rouge">cs_insn</code> type is a datatype
used by the internal <a href="http://www.capstone-engine.org/">Capstone</a> disassembler to
represent an instruction. The second is responsible for writing out the
instrumented instruction (or set of instructions). We will cover these in more
detail later.</p>

<p>Rather than using the default transformer, the user can instead provide a custom
implementation which can replace and insert instructions at will. A good example
is provided in the <a href="../javascript-api/index.html#stalker">API
documentation</a>.</p>

<h3 id="callouts">Callouts</h3>

<p>Transformers can also make callouts. That is they instruct Stalker to emit
instructions to make a call to a JavaScript function – or plain C callback,
e.g. implemented using CModule – passing the CPU context and an optional
context parameter. This function is then able to modify or inspect registers at
will. This information is stored in a <code class="language-plaintext highlighter-rouge">GumCallOutEntry</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">GumStalkerCallout</span><span class="p">)</span> <span class="p">(</span><span class="n">GumCpuContext</span> <span class="o">*</span> <span class="n">cpu_context</span><span class="p">,</span>
    <span class="n">gpointer</span> <span class="n">user_data</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumCalloutEntry</span> <span class="n">GumCalloutEntry</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumCalloutEntry</span>
<span class="p">{</span>
  <span class="n">GumStalkerCallout</span> <span class="n">callout</span><span class="p">;</span>
  <span class="n">gpointer</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">GDestroyNotify</span> <span class="n">data_destroy</span><span class="p">;</span>

  <span class="n">gpointer</span> <span class="n">pc</span><span class="p">;</span>

  <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">exec_context</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<h3 id="eobeoi">EOB/EOI</h3>

<p>Recall that the
<a href="https://github.com/frida/frida-gum/blob/master/gum/arch-arm64/gumarm64relocator.c">Relocator</a>
is heavily involved in generating the instrumented code. It has two important
properties which control its state.</p>

<p>End of Block (EOB) indicates that the end of a block has been reached. This
occurs when we encounter <em>any</em> branch instruction. A branch, a call, or a return
instruction.</p>

<p>End of Input (EOI) indicates that not only have we reached the end of a block,
but we have possibly reached the end of the input, i.e. what follows this
instruction may not be another instruction. Whilst this is not the case for a
call instruction as code control will (typically) pass back when the callee
returns and so more instructions must follow. (Note that a compiler will
typically generate a branch instruction for a call to a non-returning function
like <code class="language-plaintext highlighter-rouge">exit()</code>.) Whilst there is no guarantee of valid instructions following
call instructions, we can speculatively optimize for this being the case. If we
encounter a non-conditional branch instruction, or a return instruction, it is
quite possible that there will be no code following afterwards.</p>

<h3 id="prologuesepilogues">Prologues/Epilogues</h3>

<p>When control flow is redirected from the program into the Stalker engine, the
registers of the CPU must be saved so that Stalker can run and make use of the
registers and restore them before control is passed back to the program so that
no state is lost.</p>

<p>The <a href="https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf">Procedure Call
Standard</a>
for AArch64 states that some registers (notably X19 to X29) are callee saved
registers. This means that when the compiler generates code which makes use of
these registers, it must store them first. Hence it is not strictly necessary to
save these registers to the context structure, since they will be restored if
they are used by the code within the Stalker engine. This <em>“minimal”</em> context is
sufficient for most purposes.</p>

<p>However, if the Stalker engine is to call a probe registered by
<code class="language-plaintext highlighter-rouge">Stalker.addCallProbe()</code>, or a callout created by <code class="language-plaintext highlighter-rouge">iterator.putCallout()</code>
(called by a Transformer), then these callbacks will expect to receive the full
CPU context as an argument. And they will expect to be able to modify this
context and for the changes to take effect when control is passed back to the
application code. Thus for these instances, we must write a <em>“full”</em> context and
its layout must match the expected format dictated by the structure
<code class="language-plaintext highlighter-rouge">GumArm64CpuContext</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumArm64CpuContext</span> <span class="n">GumArm64CpuContext</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumArm64CpuContext</span>
<span class="p">{</span>
  <span class="n">guint64</span> <span class="n">pc</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">sp</span><span class="p">;</span> <span class="cm">/* X31 */</span>
  <span class="n">guint64</span> <span class="n">x</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
  <span class="n">guint64</span> <span class="n">fp</span><span class="p">;</span> <span class="cm">/* X29 - frame pointer */</span>
  <span class="n">guint64</span> <span class="n">lr</span><span class="p">;</span> <span class="cm">/* X30 */</span>
  <span class="n">guint8</span> <span class="n">q</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span> <span class="cm">/* FPU, NEON (SIMD), CRYPTO regs */</span>
<span class="p">};</span></code></pre></figure>

<p>Note however, that the code necessary to write out the necessary CPU registers
(the prologue) in either case is quite long (tens of instructions). And the code
to restore them afterwards (the epilogue) is similar in length. We don’t want to
write these at the beginning and end of every block we instrument. Therefore we
write these (in the same way we write the instrumented blocks) into a common
memory location and simply emit call instructions at the beginning and end of
each instrumented block to call these functions. These common memory locations
are referred to as <em>helpers</em>. The following functions create these prologues and
epilogues.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">gum_exec_ctx_write_minimal_prolog_helper</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gum_exec_ctx_write_minimal_epilog_helper</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gum_exec_ctx_write_full_prolog_helper</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gum_exec_ctx_write_full_epilog_helper</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">);</span></code></pre></figure>

<p>Finally, note that in the AArch64 architecture, it is only possible to make a
direct branch to code within ±128 MB of the caller, and using an indirect branch
is more expensive (both in terms of code size and performance). Therefore, as we
write more and more instrumented blocks, we will get further and further away
from the shared prologue and epilogue. If we get more than 128 MB away, we
simply write out another copy of these prologues and epilogues to use. This
gives us a very reasonable tradeoff.</p>

<h3 id="counters">Counters</h3>

<p>Finally, there are a series of counters which you can see kept recording the
number of each type of instructions encountered at the end of an instrumented
block. These are only used by the test-suite to guide the developer during
performance tuning, indicating which branch types most commonly require a full
context-switch into Stalker to resolve the target.</p>

<h2 id="slabs">Slabs</h2>

<p>Let’s now take a look at where Stalker stores its instrumented code, in slabs.
Below are the data-structures used to hold it all:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">guint8</span> <span class="n">GumExecBlockFlags</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumExecBlock</span> <span class="n">GumExecBlock</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumSlab</span> <span class="n">GumSlab</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumExecBlock</span>
<span class="p">{</span>
  <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">;</span>
  <span class="n">GumSlab</span> <span class="o">*</span> <span class="n">slab</span><span class="p">;</span>

  <span class="n">guint8</span> <span class="o">*</span> <span class="n">real_begin</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">real_end</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">real_snapshot</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">code_begin</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">code_end</span><span class="p">;</span>

  <span class="n">GumExecBlockFlags</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">gint</span> <span class="n">recycle_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">_GumSlab</span>
<span class="p">{</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>
  <span class="n">guint</span> <span class="n">offset</span><span class="p">;</span>
  <span class="n">guint</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">GumSlab</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>

  <span class="n">guint</span> <span class="n">num_blocks</span><span class="p">;</span>
  <span class="n">GumExecBlock</span> <span class="n">blocks</span><span class="p">[];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">_GumExecBlockFlags</span>
<span class="p">{</span>
  <span class="n">GUM_EXEC_ACTIVATION_TARGET</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">};</span></code></pre></figure>

<p>Now let’s look at some code when Stalker is initialized which configures their
size:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define GUM_CODE_SLAB_MAX_SIZE  (4 * 1024 * 1024)
#define GUM_EXEC_BLOCK_MIN_SIZE 1024
</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_stalker_init</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">gum_query_page_size</span> <span class="p">();</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">slab_size</span> <span class="o">=</span>
      <span class="n">GUM_ALIGN_SIZE</span> <span class="p">(</span><span class="n">GUM_CODE_SLAB_MAX_SIZE</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">slab_header_size</span> <span class="o">=</span>
      <span class="n">GUM_ALIGN_SIZE</span> <span class="p">(</span><span class="n">GUM_CODE_SLAB_MAX_SIZE</span> <span class="o">/</span> <span class="mi">12</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">);</span>
  <span class="n">self</span><span class="o">-&gt;</span><span class="n">slab_max_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">slab_header_size</span> <span class="o">-</span>
      <span class="n">G_STRUCT_OFFSET</span> <span class="p">(</span><span class="n">GumSlab</span><span class="p">,</span> <span class="n">blocks</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GumExecBlock</span><span class="p">);</span>

  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>So we can see that each slab is 4 MB in size. A 12th of this slab is reserved
for its header, the <code class="language-plaintext highlighter-rouge">GumSlab</code> structure itself including its <code class="language-plaintext highlighter-rouge">GumExecBlock</code>
array. Note that this is defined as a zero length array at the end of the
<code class="language-plaintext highlighter-rouge">GumSlab</code> structure, but the actual number of these which can fit in the header
of the slab is calculated and stored in <code class="language-plaintext highlighter-rouge">slab_max_blocks</code>.</p>

<p>So what is the remainder of the slab used for? Whilst the header of the slab is
used for all the accounting information, the remainder (henceforth referred to
as the tail) of the slab is used for the instrumented instructions themselves
(they are stored inline in the slab).</p>

<p>So why is a 12th of the slab allocated for the header and the remainder for the
instructions? Well the length of each block to be instrumented will vary
considerably and may be affected by the compiler being used and its optimization
settings. Some rough empirical testing showed that given the average length of
each block this might be a reasonable ratio to ensure we didn’t run out of space
for new <code class="language-plaintext highlighter-rouge">GumExecBlock</code> entries before we ran out of space for new instrumented
blocks in the tail and vice versa.</p>

<p>Let’s now look at the code which creates them:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">GumSlab</span> <span class="o">*</span>
<span class="nf">gum_exec_ctx_add_slab</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumSlab</span> <span class="o">*</span> <span class="n">slab</span><span class="p">;</span>
  <span class="n">GumStalker</span> <span class="o">*</span> <span class="n">stalker</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stalker</span><span class="p">;</span>

  <span class="n">slab</span> <span class="o">=</span> <span class="n">gum_memory_allocate</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">slab_size</span><span class="p">,</span>
      <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span>
      <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">is_rwx_supported</span> <span class="o">?</span> <span class="n">GUM_PAGE_RWX</span> <span class="o">:</span> <span class="n">GUM_PAGE_RW</span><span class="p">);</span>

  <span class="n">slab</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">guint8</span> <span class="o">*</span><span class="p">)</span> <span class="n">slab</span> <span class="o">+</span> <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">slab_header_size</span><span class="p">;</span>
  <span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">slab</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">slab_size</span> <span class="o">-</span> <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">slab_header_size</span><span class="p">;</span>
  <span class="n">slab</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">code_slab</span><span class="p">;</span>

  <span class="n">slab</span><span class="o">-&gt;</span><span class="n">num_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">code_slab</span> <span class="o">=</span> <span class="n">slab</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">slab</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Here, we can see that the <code class="language-plaintext highlighter-rouge">data</code> field points to the start of the tail where
instructions can be written after the header. The <code class="language-plaintext highlighter-rouge">offset</code> field keeps track of
our offset into the tail. The <code class="language-plaintext highlighter-rouge">size</code> field keeps track of the total number of
bytes available in the tail. The <code class="language-plaintext highlighter-rouge">num_blocks</code> field keeps track of how many
instrumented blocks have been written to the slab.</p>

<p>Note that where possible we allocate the slab with RWX permissions so that we
don’t have to freeze and thaw it all of the time. On systems which support RWX
the freeze and thaw functions become no-ops.</p>

<p>Lastly, we can see that each slab contains a <code class="language-plaintext highlighter-rouge">next</code> pointer which can be used to
link slabs together to form a singly-linked list. This is used so we can walk
them and dispose them all when Stalker is finished.</p>

<h2 id="blocks">Blocks</h2>

<p>Now we understand how the slabs work. Let’s look in more detail at the blocks.
As we know, we can store multiple blocks in a slab and write their instructions
to the tail. Let’s look at the code to allocate a new block:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">GumExecBlock</span> <span class="o">*</span>
<span class="nf">gum_exec_block_new</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumStalker</span> <span class="o">*</span> <span class="n">stalker</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stalker</span><span class="p">;</span>
  <span class="n">GumSlab</span> <span class="o">*</span> <span class="n">slab</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">code_slab</span><span class="p">;</span>
  <span class="n">gsize</span> <span class="n">available</span><span class="p">;</span>

  <span class="n">available</span> <span class="o">=</span> <span class="p">(</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">available</span> <span class="o">&gt;=</span> <span class="n">GUM_EXEC_BLOCK_MIN_SIZE</span> <span class="o">&amp;&amp;</span>
      <span class="n">slab</span><span class="o">-&gt;</span><span class="n">num_blocks</span> <span class="o">!=</span> <span class="n">stalker</span><span class="o">-&gt;</span><span class="n">slab_max_blocks</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span> <span class="o">=</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">+</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">num_blocks</span><span class="p">;</span>

    <span class="n">block</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
    <span class="n">block</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">slab</span><span class="p">;</span>

    <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_begin</span> <span class="o">=</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
    <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_end</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_begin</span><span class="p">;</span>

    <span class="n">block</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">block</span><span class="o">-&gt;</span><span class="n">recycle_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">gum_stalker_thaw</span> <span class="p">(</span><span class="n">stalker</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_begin</span><span class="p">,</span> <span class="n">available</span><span class="p">);</span>
    <span class="n">slab</span><span class="o">-&gt;</span><span class="n">num_blocks</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">stalker</span><span class="o">-&gt;</span><span class="n">trust_threshold</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">gum_exec_block_new</span> <span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">gum_exec_ctx_add_slab</span> <span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_inline_helpers_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">gum_exec_block_new</span> <span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The function first checks if there is space for a minimally sized block in the
tail of the slab (1024 bytes) and whether there is space in the array of
<code class="language-plaintext highlighter-rouge">GumExecBlocks</code> in the slab header for a new entry. If it does then a new entry
is created in the array and its pointers are set to reference the <code class="language-plaintext highlighter-rouge">GumExecCtx</code>
(the main Stalker session context) and the <code class="language-plaintext highlighter-rouge">GumSlab</code>, The <code class="language-plaintext highlighter-rouge">code_begin</code> and
<code class="language-plaintext highlighter-rouge">code_end</code> pointers are both set to the first free byte in the tail. The
<code class="language-plaintext highlighter-rouge">recycle_count</code> used by the trust threshold mechanism to determine how many
times the block has been encountered unmodified is reset to zero, and the
remainder of the tail is thawed to allow code to be written to it.</p>

<p>Next if the trust threshold is set to less than zero (recall -1 means blocks are
never trusted and always re-written) then we reset the slab <code class="language-plaintext highlighter-rouge">offset</code> (the
pointer to the first free byte in the tail) and start over. This means that any
instrumented code written for any blocks within the slab will be overwritten.</p>

<p>Finally, as there is no space left in the current slab and we can’t overwrite it
because the trust threshold means blocks may be re-used, then we must allocate a
new slab by calling <code class="language-plaintext highlighter-rouge">gum_exec_ctx_add_slab()</code>, which we looked at above. We then
call <code class="language-plaintext highlighter-rouge">gum_exec_ctx_ensure_inline_helpers_reachable()</code>, more on that in a moment,
and then we allocate our block from the new slab.</p>

<p>Recall, that we use <em>helpers</em> (such as the prologues and epilogues that save and
restore the CPU context) to prevent having to duplicate these instructions at
the beginning and end of every block. As we need to be able to call these from
instrumented code we are writing to the slab, and we do so with a direct branch
that can only reach ±128 MB from the call site, we need to ensure we can get to
them. If we haven’t written them before, then we write them to our current slab.
Note that these helper funtions need to be reachable from any instrumented
instruction written in the tail of the slab. Because our slab is only 4 MB in
size, then if our helpers are written in our current slab then they will be
reachable just fine. If we are allocating a subsequent slab and it is close
enough to the previous slab (we only retain the location we last wrote the
helper functions to) then we might not need to write them out again and can just
rely upon the previous copy in the nearby slab. Note that we are at the mercy of
<code class="language-plaintext highlighter-rouge">mmap()</code> for where our slab is allocated in virtual memory and ASLR may dictate
that our slab ends up nowhere near the previous one.</p>

<p>We can only assume that either this is unlikely to be a problem, or that this
has been factored into the size of the slabs to ensure that writing the helpers
to each slab isn’t much of an overhead because it doesn’t use a significant
proportion of their space. An alternative could be to store every location every
time we have written out a helper function so that we have more candidates to
choose from (maybe our slab isn’t allocated nearby the one previously allocated,
but perhaps it is close enough to one of the others). Otherwise, we could
consider making a custom allocator using <code class="language-plaintext highlighter-rouge">mmap()</code> to reserve a large (e.g. 128
MB) region of virtual address space and then use <code class="language-plaintext highlighter-rouge">mmap()</code> again to commit the
memory one slab at a time as needed. But these ideas are perhaps both overkill.</p>

<h2 id="instrumenting-blocks">Instrumenting Blocks</h2>

<p>The main function which instruments a code block is called
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code>. It first looks for an existing block in the
hash table which is indexed on the address of the original block which was
instrumented. If it finds one and the aforementioned constraints around the
trust threshold are met then it can simply be returned.</p>

<p>The fields of the <code class="language-plaintext highlighter-rouge">GumExecBlock</code> are used as follows. The <code class="language-plaintext highlighter-rouge">real_begin</code> is set to
the start of the original block of code to be instrumented. The <code class="language-plaintext highlighter-rouge">code_begin</code>
field points to the first free byte of the tail (remember this was set by the
<code class="language-plaintext highlighter-rouge">gum_exec_block_new()</code> function discussed above). A <code class="language-plaintext highlighter-rouge">GumArm64Relocator</code> is
initialized to read code from the original code at <code class="language-plaintext highlighter-rouge">real_begin</code> and a
<code class="language-plaintext highlighter-rouge">GumArm64Writer</code> is initialized to write its output to the slab starting at
<code class="language-plaintext highlighter-rouge">code_begin</code>. Each of these items is packaged into a <code class="language-plaintext highlighter-rouge">GumGeneratorContext</code> and
finally this is used to construct a <code class="language-plaintext highlighter-rouge">GumStalkerIterator</code>.</p>

<p>This iterator is then passed to the transformer. Recall the default
implementations is as follows:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_default_stalker_transformer_transform_block</span> <span class="p">(</span>
    <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span>
    <span class="n">GumStalkerIterator</span> <span class="o">*</span> <span class="n">iterator</span><span class="p">,</span>
    <span class="n">GumStalkerOutput</span> <span class="o">*</span> <span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">gum_stalker_iterator_next</span> <span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">gum_stalker_iterator_keep</span> <span class="p">(</span><span class="n">iterator</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We will gloss over the details of <code class="language-plaintext highlighter-rouge">gum_stalker_iterator_next()</code> and
<code class="language-plaintext highlighter-rouge">gum_stalker_iterator_keep()</code> for now. But in essence, this causes the iterator
to read code one instruction at a time from the relocator, and write the
relocated instruction out using the writer. Following this process, the
<code class="language-plaintext highlighter-rouge">GumExecBlock</code> structure can be updated. Its field <code class="language-plaintext highlighter-rouge">real_end</code> can be set to the
address where the relocator read up to, and its field <code class="language-plaintext highlighter-rouge">code_end</code> can be set to
the address which the writer wrote up to. Thus <code class="language-plaintext highlighter-rouge">real_begin</code> and <code class="language-plaintext highlighter-rouge">real_end</code> mark
the limits of the original block, and <code class="language-plaintext highlighter-rouge">code_begin</code> and <code class="language-plaintext highlighter-rouge">code_end</code> mark the
limits of the newly instrumented block. Finally,
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> calls <code class="language-plaintext highlighter-rouge">gum_exec_block_commit()</code> which takes a
copy of the original block and places it immediately after the instrumented
copy. The field <code class="language-plaintext highlighter-rouge">real_snapshot</code> points to this (and is thus identical to
<code class="language-plaintext highlighter-rouge">code_end</code>). Next the slab’s <code class="language-plaintext highlighter-rouge">offset</code> field is updated to reflect the space used
by our instrumented block and our copy of the original code. Finally, the block
is frozen to allow it to be executed.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_block_commit</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gsize</span> <span class="n">code_size</span><span class="p">,</span> <span class="n">real_size</span><span class="p">;</span>

  <span class="n">code_size</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_end</span> <span class="o">-</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_begin</span><span class="p">;</span>
  <span class="n">block</span><span class="o">-&gt;</span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">code_size</span><span class="p">;</span>

  <span class="n">real_size</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">real_end</span> <span class="o">-</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">real_begin</span><span class="p">;</span>
  <span class="n">block</span><span class="o">-&gt;</span><span class="n">real_snapshot</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_end</span><span class="p">;</span>
  <span class="n">memcpy</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">real_snapshot</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">real_begin</span><span class="p">,</span> <span class="n">real_size</span><span class="p">);</span>
  <span class="n">block</span><span class="o">-&gt;</span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">real_size</span><span class="p">;</span>

  <span class="n">gum_stalker_freeze</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stalker</span><span class="p">,</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_begin</span><span class="p">,</span>
      <span class="n">code_size</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s just return to a few more details of the function
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code>. First we should note that each block has a
single instruction prefixed.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">gum_arm64_writer_put_ldp_reg_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X16</span><span class="p">,</span>
    <span class="n">ARM64_REG_X17</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">GUM_RED_ZONE_SIZE</span><span class="p">,</span>
    <span class="n">GUM_INDEX_POST_ADJUST</span><span class="p">);</span></code></pre></figure>

<p>This instruction is the restoration prolog (denoted by
<code class="language-plaintext highlighter-rouge">GUM_RESTORATION_PROLOG_SIZE</code>). This is skipped in “bootstrap” usage – hence you
will note this constant is added on by <code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code> and
<code class="language-plaintext highlighter-rouge">gum_stalker_infect()</code> when returning the address of the instrumented code. When
return instructions are instrumented, however, if the return is to a block which
has already been instrumented, then we can simply return to that block rather
than returning back into the Stalker engine. This code is written by
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_ret_transfer_code()</code>. In a worst-case scenario, where we
may need to use registers to perform the final branch to the instrumented block,
this function stores them into the stack, and the code to restore these from the
stack is prefixed in the block itself. Hence, in the event that we can return
directly to an instrumented block, we return to this first instruction rather
than skipping <code class="language-plaintext highlighter-rouge">GUM_RESTORATION_PROLOG_SIZE</code> bytes.</p>

<p>Secondly, we can see <code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> does the following after
the instrumented block is written:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">gum_arm64_writer_put_brk_imm</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span></code></pre></figure>

<p>This inserts a break instruction which is intended to simplify debugging.</p>

<p>Lastly, if Stalker is configured to, <code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> will
generate an event of type <code class="language-plaintext highlighter-rouge">GUM_COMPILE</code> when compiling the block.</p>

<h2 id="helpers">Helpers</h2>

<p>We can see from <code class="language-plaintext highlighter-rouge">gum_exec_ctx_ensure_inline_helpers_reachable()</code> that we have a
total of 6 helpers. These helpers are common fragments of code which are needed
repeatedly by our instrumented blocks. Rather than emitting the code they
contain repeatedly, we instead write it once and place a call or branch
instruction to have our instrumented code execute it. Recall that the helpers
are written into the same slabs we are writing our instrumented code into and
that if possible we can re-use the helper written into a previous nearby slab
rather than putting a copy in each one.</p>

<p>This function calls <code class="language-plaintext highlighter-rouge">gum_exec_ctx_ensure_helper_reachable()</code> for each helper
which in turn calls <code class="language-plaintext highlighter-rouge">gum_exec_ctx_is_helper_reachable()</code> to check if the helper
is within range, or otherwise calls the callback passed as the second argument
to write out a new copy.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_ensure_inline_helpers_reachable</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_prolog_minimal</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_minimal_prolog_helper</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_epilog_minimal</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_minimal_epilog_helper</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_prolog_full</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_full_prolog_helper</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_epilog_full</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_full_epilog_helper</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_stack_push</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_stack_push_helper</span><span class="p">);</span>

  <span class="n">gum_exec_ctx_ensure_helper_reachable</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_stack_pop_and_go</span><span class="p">,</span>
      <span class="n">gum_exec_ctx_write_stack_pop_and_go_helper</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>So, what are our 6 helpers. We have 2 for writing prologues which store register
context, one for a full context and one for a minimal context. We will cover
these later. We also have 2 for their corresponding epilogues for restoring the
registers. The other two, the <code class="language-plaintext highlighter-rouge">last_stack_push</code> and <code class="language-plaintext highlighter-rouge">last_stack_pop_and_go</code> are
used when instrumenting call instructions.</p>

<p>Before we analyze these two in detail, we first need to understand the frame
structures. We can see from the code snippets below that we allocate a page to
contain <code class="language-plaintext highlighter-rouge">GumExecFrame</code> structures. These structures are stored sequentially in
the page like an array and are populated starting with the entry at the end of
the page. Each frame contains the address of the original block and the address
of the instrumented block which we generated to replace it:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumExecFrame</span> <span class="n">GumExecFrame</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GumExecCtx</span> <span class="n">GumExecCtx</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumExecFrame</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="n">real_address</span><span class="p">;</span>
  <span class="n">gpointer</span> <span class="n">code_address</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">_GumExecCtx</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="n">GumExecFrame</span> <span class="o">*</span> <span class="n">current_frame</span><span class="p">;</span>
  <span class="n">GumExecFrame</span> <span class="o">*</span> <span class="n">first_frame</span><span class="p">;</span>
  <span class="n">GumExecFrame</span> <span class="o">*</span> <span class="n">frames</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">GumExecCtx</span> <span class="o">*</span>
<span class="nf">gum_stalker_create_exec_ctx</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                             <span class="n">GumThreadId</span> <span class="n">thread_id</span><span class="p">,</span>
                             <span class="n">GumStalkerTransformer</span> <span class="o">*</span> <span class="n">transformer</span><span class="p">,</span>
                             <span class="n">GumEventSink</span> <span class="o">*</span> <span class="n">sink</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">=</span> <span class="n">gum_memory_allocate</span> <span class="p">(</span>
      <span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="n">GUM_PAGE_RW</span><span class="p">);</span>
  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">GumExecFrame</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">guint8</span> <span class="o">*</span><span class="p">)</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">frames</span> <span class="o">+</span>
      <span class="n">self</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GumExecFrame</span><span class="p">));</span>
  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_frame</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_frame</span><span class="p">;</span>

  <span class="p">...</span>

  <span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3 id="last_stack_push">last_stack_push</h3>

<p>Much of the complexity in understanding Stalker and the helpers in particular is
that some functions – let’s call them writers – write code which is executed at
a later point. These writers have branches in themselves which determine exactly
what code to write, and the written code can also sometimes have branches too.
The approach I will take for these two helpers therefore is to show pseudo code
for the assembly which is emitted into the slab which will be called by
instrumented blocks.</p>

<p>The pseudo code for this helper is shown below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">last_stack_push_helper</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">x0</span><span class="p">,</span>
                        <span class="n">gpointer</span> <span class="n">x1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumExecFrame</span> <span class="o">**</span> <span class="n">x16</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_frame</span>
  <span class="n">GumExecFrame</span> <span class="o">*</span> <span class="n">x17</span> <span class="o">=</span> <span class="o">*</span><span class="n">x16</span>
  <span class="n">gpointer</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x17</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stalker</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">:</span>
    <span class="n">x17</span><span class="o">--</span>
    <span class="n">x17</span><span class="o">-&gt;</span><span class="n">real_address</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">x17</span><span class="o">-&gt;</span><span class="n">code_address</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="o">*</span><span class="n">x16</span> <span class="o">=</span> <span class="n">x17</span>
  <span class="k">return</span>
<span class="p">}</span></code></pre></figure>

<p>As we can see, this helper is actually a simple function which takes two
arguments, the <code class="language-plaintext highlighter-rouge">real_address</code> and the <code class="language-plaintext highlighter-rouge">code_address</code> to store in the next
<code class="language-plaintext highlighter-rouge">GumExecFrame</code> structure. Note that our stack is written backwards from the end
of the page in which they are stored towards the start and that <code class="language-plaintext highlighter-rouge">current_frame</code>
points to the last used entry (so our stack is full and descending). Also note
we have a conditional check to see whether we are on the last entry (the one at
the very beginning of the page will be page-aligned) and if we have run out of
space for more entries (we have space for 512) then we simply do nothing. If we
have space, we write the values from the parameters into the entry and retard
the <code class="language-plaintext highlighter-rouge">current_frame</code> pointer to point to it.</p>

<p>This helper is used when <em>virtualizing</em> call instructions. Virtualizing is the
name given to the replacement of an instruction typically those relating to
branching with a series of instructions which instead of executing the intended
block allow Stalker to manage the control-flow. Recall as our transformer walks
the instructions using the iterator and calls <code class="language-plaintext highlighter-rouge">iterator.keep()</code> we output our
transformed instruction. When we encounter a branch, we need to emit code to
call back into the Stalker engine so that it can instrument that block, but if
the branch statement is a call instruction (<code class="language-plaintext highlighter-rouge">BL</code>, <code class="language-plaintext highlighter-rouge">BLX</code> etc) we also need to
emit a call to the above helper to store the stack frame information. This
information is used when emitting call events as well as later when optimizing
the return.</p>

<h3 id="last_stack_pop_and_go">last_stack_pop_and_go</h3>

<p>Now lets look at the <code class="language-plaintext highlighter-rouge">last_stack_pop_and_go</code> helper. To understand this, we also
need to understand the code written by
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_ret_transfer_code()</code> (the code that calls it), as well as
that written by <code class="language-plaintext highlighter-rouge">gum_exec_block_write_exec_generated_code()</code> which it calls. We
will skip over pointer authentication for now.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">ret_transfer_code</span> <span class="p">(</span><span class="n">arm64_reg</span> <span class="n">ret_reg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="n">x16</span> <span class="o">=</span> <span class="n">ret_reg</span>
  <span class="k">goto</span> <span class="n">last_stack_pop_and_go_helper</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">last_stack_pop_and_go_helper</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">x16</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumExecFrame</span> <span class="o">**</span> <span class="n">x0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_frame</span>
  <span class="n">GumExecFrame</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">*</span><span class="n">x0</span>
  <span class="n">gpointer</span> <span class="n">x17</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">real_address</span>
  <span class="k">if</span> <span class="n">x17</span> <span class="o">==</span> <span class="n">x16</span><span class="o">:</span>
    <span class="n">x17</span> <span class="o">=</span> <span class="n">x0</span><span class="o">-&gt;</span><span class="n">code_address</span>
    <span class="n">x1</span><span class="o">++</span>
    <span class="o">*</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="k">goto</span> <span class="n">x17</span>
  <span class="nl">else:</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">first_frame</span>
    <span class="o">*</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>
    <span class="n">gpointer</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">return_at</span>
    <span class="o">*</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x16</span>
    <span class="n">last_prologue_minimal</span><span class="p">()</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">return_at</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="o">*</span><span class="n">x0</span>
    <span class="n">gum_exec_ctx_replace_current_block_from_ret</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
    <span class="n">last_epilogue_minimal</span><span class="p">()</span>
    <span class="k">goto</span> <span class="n">exec_generated_code</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">exec_generated_code</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="o">*</span> <span class="n">x16</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span>
  <span class="n">gpointer</span> <span class="n">x17</span> <span class="o">=</span> <span class="o">*</span><span class="n">x16</span>
  <span class="k">goto</span> <span class="n">x17</span>
<span class="p">}</span></code></pre></figure>

<p>So this code is a little harder. It isn’t really a function and the actual
assembly written by it is muddied a little by the need to save and restore
registers. But the essence of it is this: When virtualizing a return instruction
this helper is used to optimize passing control back to the caller. ret_reg
contains the address of the block to which we are intending to return.</p>

<p>Lets take a look at the definition of the return instruction:</p>

<blockquote>
  <p>RET
Return from subroutine, branches unconditionally to an address
in a register, with a hint that this is a subroutine return.</p>

  <p>RET  {Xn}
Where:</p>

  <p>Xn
Is the 64-bit name of the general-purpose register holding the
address to be branched to, in the range 0 to 31. Defaults to
X30 if absent.</p>
</blockquote>

<p>As we can see, we are going to return to an address passed in a register.
Typically, we can predict the register value and where we will return to, as the
compiler will emit assembly code so that the register is set to the address of
the instruction immediately following the call which got us there. After
emitting an instrumented call, we emit directly after a little landing pad which
will call back into Stalker to instrument the next block. This landing pad can
later be backpatched (if the conditions are right) to avoid re-entering Stalker
altogether. We store the addresses of both the original block following the call
and this landing pad in the <code class="language-plaintext highlighter-rouge">GumExecFrame</code> structure, so we can simply
virtualize our return instruction by replacing it with instructions which simply
branch to this landing pad. We don’t need to re-enter the Stalker engine each
time we see a return instruction and get a nice performance boost. Simple!</p>

<p>However, we must bear in mind that not all calls will result in a return. A
common technique for hostile or specialized code is to make a call in order to
use the <code class="language-plaintext highlighter-rouge">LR</code> to determine the current position of the instruction pointer. This
value may then be used for introspection purposes (e.g. to validate code to
detect modification, to decrypt or unscramble code, etc.).</p>

<p>Also, remember that the user can use a custom transform to modify
instructions as they see fit, they can insert instructions which modify register
values, or perhaps a callout function which is passed the context structure
which allows them to modify register values as they like. Now consider what if
they modify the value in the return register!</p>

<p>So we can see that the helper checks the value of the return register against
the value of the <code class="language-plaintext highlighter-rouge">real_address</code> stored in the <code class="language-plaintext highlighter-rouge">GumExecFrame</code>. If it matches,
then all is well and we can simply branch directly back to the landing pad.
Recall on the first instance, this simply re-enters Stalker to instrument the
next block and branches to it, but at a later point backpatching may be used to
directly branch to this instrumented block and avoid re-entering Stalker
altogether.</p>

<p>Otherwise, we follow a different path. First the array of <code class="language-plaintext highlighter-rouge">GumExecFrame</code> is
cleared, now our control-flow has deviated, we will start again building our
stack again. We accept that we will take this same slower path for any previous
frames in the call-stack we recorded so far if we ever return to them, but will
have the possibility of using the fast path for new calls we encounter from here
on out (until the next time a call instruction is used in an unconventional
manner).</p>

<p>We make a minimal prologue (our instrumented code is now going to have to
re-enter Stalker) and we need to be able to restore the application’s registers
before we return control back to it. We call the entry gate for return,
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_from_ret()</code> (more on entry gates later). We
then execute the corresponding epilogue before branching to the <code class="language-plaintext highlighter-rouge">ctx-&gt;resume_at</code>
pointer which is set by Stalker during the above call to
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_from_ret()</code> to point to the new instrumented
block.</p>

<h2 id="context">Context</h2>

<p>Let’s look at the prologues and epilogues now.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_write_prolog</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                           <span class="n">GumPrologType</span> <span class="n">type</span><span class="p">,</span>
                           <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="n">helper</span><span class="p">;</span>

  <span class="n">helper</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_MINIMAL</span><span class="p">)</span>
      <span class="o">?</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_prolog_minimal</span>
      <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_prolog_full</span><span class="p">;</span>

  <span class="n">gum_arm64_writer_put_stp_reg_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">,</span>
      <span class="n">ARM64_REG_LR</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">16</span> <span class="o">+</span> <span class="n">GUM_RED_ZONE_SIZE</span><span class="p">),</span>
      <span class="n">GUM_INDEX_PRE_ADJUST</span><span class="p">);</span>
  <span class="n">gum_arm64_writer_put_bl_imm</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="n">helper</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_write_epilog</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                           <span class="n">GumPrologType</span> <span class="n">type</span><span class="p">,</span>
                           <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">gpointer</span> <span class="n">helper</span><span class="p">;</span>

  <span class="n">helper</span> <span class="o">=</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_MINIMAL</span><span class="p">)</span>
      <span class="o">?</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_epilog_minimal</span>
      <span class="o">:</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_epilog_full</span><span class="p">;</span>

  <span class="n">gum_arm64_writer_put_bl_imm</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="n">helper</span><span class="p">));</span>
  <span class="n">gum_arm64_writer_put_ldp_reg_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">,</span>
      <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">GUM_RED_ZONE_SIZE</span><span class="p">,</span>
      <span class="n">GUM_INDEX_POST_ADJUST</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>We can see that these do little other than call the corresponding prologue or
epilogue helpers. We can see that the prologue will store <code class="language-plaintext highlighter-rouge">X19</code> and the link
register onto the stack. These are then restored into <code class="language-plaintext highlighter-rouge">X19</code> and <code class="language-plaintext highlighter-rouge">X20</code> at the end
of the epilogue.  This is because <code class="language-plaintext highlighter-rouge">X19</code> is needed as scratch space to write the
context blocks and the link register needs to be preserved as it will be
clobbered by the call to the helper.</p>

<p>The LDP and STP instructions load and store a pair of registers respectively and
have the option to increment or decrement the stack pointer. This increment or
decrement can be carried out either before, or after the values are loaded or
stored.</p>

<p>Note also the offset at which these registers are placed. They are stored at
<code class="language-plaintext highlighter-rouge">16</code> bytes + <code class="language-plaintext highlighter-rouge">GUM_RED_ZONE_SIZE</code> beyond the top of the stack. Note that our
stack on AArch64 is full and descending. This means that the stack grows toward
lower addresses and the stack pointer points to the last item pushed (not to the
next empty space). So, if we subtract 16 bytes from the stack pointer, then this
gives us enough space to store the two 64-bit registers. Note that the stack
pointer must be decremented before the store (pre-decrement) and incremented
after the load (post-increment).</p>

<p>So what is <code class="language-plaintext highlighter-rouge">GUM_RED_ZONE_SIZE</code>? The
<a href="http://hungri-yeti.com/2015/10/19/the-arm64-aarch64-stack/">redzone</a> is a 128
byte area beyond the stack pointer which a function can use to store temporary
variables. This allows a function to store data in the stack without the need to
adjust the stack pointer all of the time. Note that this call to the prologue is
likely the first thing to be carried out in our instrumented block, we don’t
know what local variables the application code has stored in the redzone and so
we must ensure that we advance the stackpointer beyond it before we start using
the stack to store information for the Stalker engine.</p>

<h2 id="context-helpers">Context Helpers</h2>

<p>Now that we have looked at how these helpers are called, let us now have a look
at the helpers themselves. Although there are two prologues and two epilogues
(full and minimal), they are both written by the same function as they have much
in common. The version which is written is based on the function parameters. The
easiest way to present these is with annotated code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_write_prolog_helper</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                                  <span class="n">GumPrologType</span> <span class="n">type</span><span class="p">,</span>
                                  <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Keep track of how much we are pushing onto the stack since we</span>
  <span class="c1">// will want to store in the exec context where the original app</span>
  <span class="c1">// stack was. At present the call to our helper already skipped</span>
  <span class="c1">// the red zone and stored LR and X19.</span>
  <span class="n">gint</span> <span class="n">immediate_for_sp</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">GUM_RED_ZONE_SIZE</span><span class="p">;</span>

  <span class="c1">// This instruction is used to store the CPU flags into X15.</span>
  <span class="k">const</span> <span class="n">guint32</span> <span class="n">mrs_x15_nzcv</span> <span class="o">=</span> <span class="mh">0xd53b420f</span><span class="p">;</span>

  <span class="c1">// Note that only the full prolog has to look like the C struct</span>
  <span class="c1">// definition, since this is the data structure passed to</span>
  <span class="c1">// callouts and the like.</span>

  <span class="c1">// Save Return address to our instrumented block in X19. We will</span>
  <span class="c1">// preserve this throughout and branch back there at the end.</span>
  <span class="c1">// This will take us back to the code written by</span>
  <span class="c1">// gum_exec_ctx_write_prolog()</span>
  <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">,</span> <span class="n">ARM64_REG_LR</span><span class="p">);</span>

  <span class="c1">// LR = SP[8] Save return address of previous block (or user-code)</span>
  <span class="c1">// in LR. This was pushed there by the code written by</span>
  <span class="c1">// gum_exec_ctx_write_prolog(). This is the one which will remain in</span>
  <span class="c1">// LR once we have returned to our instrumented code block. Note</span>
  <span class="c1">// the use of SP+8 is a little asymmetric on entry (prolog) as it is</span>
  <span class="c1">// used to pass LR. On exit (epilog) it is used to pass X20</span>
  <span class="c1">// and accordingly gum_exec_ctx_write_epilog() restores it there.</span>
  <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">ARM64_REG_LR</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

  <span class="c1">// Store SP[8] = X20. We have read the value of LR which was put</span>
  <span class="c1">// there by gum_exec_ctx_write_prolog() and are writing X20 there</span>
  <span class="c1">// so that it can be restored by code written by</span>
  <span class="c1">// gum_exec_ctx_write_epilog()</span>
  <span class="n">gum_arm64_writer_put_str_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_MINIMAL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Store all of the FP/NEON registers. NEON is the SIMD engine</span>
    <span class="c1">// on the ARM core which allows operations to be carried out</span>
    <span class="c1">// on multiple inputs at once.</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q6</span><span class="p">,</span> <span class="n">ARM64_REG_Q7</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q4</span><span class="p">,</span> <span class="n">ARM64_REG_Q5</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q2</span><span class="p">,</span> <span class="n">ARM64_REG_Q3</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q0</span><span class="p">,</span> <span class="n">ARM64_REG_Q1</span><span class="p">);</span>

    <span class="n">immediate_for_sp</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">32</span><span class="p">;</span>

    <span class="c1">// X29 is Frame Pointer</span>
    <span class="c1">// X30 is the Link Register</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X29</span><span class="p">,</span> <span class="n">ARM64_REG_X30</span><span class="p">);</span>

    <span class="c1">// We are using STP here to push pairs of registers. We actually</span>
    <span class="c1">// have an odd number to push, so we just push STALKER_REG_CTX</span>
    <span class="c1">// as padding to make up the numbers</span>
    <span class="cm">/* X19 - X28 are callee-saved registers */</span>

    <span class="c1">// If we are only calling compiled C code, then the compiler</span>
    <span class="c1">// will ensure that should a function use registers X19</span>
    <span class="c1">// through X28 then their values will be preserved. Hence,</span>
    <span class="c1">// we don't need to store them here as they will not be</span>
    <span class="c1">// modified. If however, we make a callout, then we want</span>
    <span class="c1">// the Stalker end user to have visibility of the full</span>
    <span class="c1">// register set and to be able to make any modifications</span>
    <span class="c1">// they see fit to them.</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X18</span><span class="p">,</span> <span class="n">ARM64_REG_X30</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X16</span><span class="p">,</span> <span class="n">ARM64_REG_X17</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X12</span><span class="p">,</span> <span class="n">ARM64_REG_X13</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X10</span><span class="p">,</span> <span class="n">ARM64_REG_X11</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X8</span><span class="p">,</span> <span class="n">ARM64_REG_X9</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X6</span><span class="p">,</span> <span class="n">ARM64_REG_X7</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X4</span><span class="p">,</span> <span class="n">ARM64_REG_X5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
       <span class="n">ARM64_REG_X2</span><span class="p">,</span> <span class="n">ARM64_REG_X3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
       <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_X1</span><span class="p">);</span>
    <span class="n">immediate_for_sp</span> <span class="o">+=</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_FULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* GumCpuContext.q[128] */</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q6</span><span class="p">,</span> <span class="n">ARM64_REG_Q7</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q4</span><span class="p">,</span> <span class="n">ARM64_REG_Q5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q2</span><span class="p">,</span> <span class="n">ARM64_REG_Q3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q0</span><span class="p">,</span> <span class="n">ARM64_REG_Q1</span><span class="p">);</span>

    <span class="cm">/* GumCpuContext.x[29] + fp + lr + padding */</span>
    <span class="c1">// X29 is Frame Pointer</span>
    <span class="c1">// X30 is the Link Register</span>
    <span class="c1">// X15 is pushed just for padding again</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X30</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X28</span><span class="p">,</span> <span class="n">ARM64_REG_X29</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X26</span><span class="p">,</span> <span class="n">ARM64_REG_X27</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X24</span><span class="p">,</span> <span class="n">ARM64_REG_X25</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X22</span><span class="p">,</span> <span class="n">ARM64_REG_X23</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_X21</span><span class="p">);</span>

    <span class="c1">// Store X19 (currently holding the LR value for this function</span>
    <span class="c1">// to return to, the address of the caller written by</span>
    <span class="c1">// gum_exec_ctx_write_prolog()) in X20 temporarily. We have</span>
    <span class="c1">// already pushed X20 so we can use it freely, but we want to</span>
    <span class="c1">// push the app's value of X19 into the context. This was</span>
    <span class="c1">// pushed onto the stack by the code in</span>
    <span class="c1">// gum_exec_ctx_write_prolog() so we can restore it from there</span>
    <span class="c1">// before we push it.</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">);</span>

    <span class="c1">// Restore X19 from the value pushed by the prolog before the</span>
    <span class="c1">// call to the helper.</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X19</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">32</span><span class="p">));</span>

    <span class="c1">// Push the app's values of X18 and X19. X18 was unmodified. We</span>
    <span class="c1">// have corrected X19 above.</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X18</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">);</span>

    <span class="c1">// Restore X19 from X20</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X19</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X16</span><span class="p">,</span> <span class="n">ARM64_REG_X17</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X12</span><span class="p">,</span> <span class="n">ARM64_REG_X13</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X10</span><span class="p">,</span> <span class="n">ARM64_REG_X11</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X8</span><span class="p">,</span> <span class="n">ARM64_REG_X9</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X6</span><span class="p">,</span> <span class="n">ARM64_REG_X7</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X4</span><span class="p">,</span> <span class="n">ARM64_REG_X5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X2</span><span class="p">,</span> <span class="n">ARM64_REG_X3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_X1</span><span class="p">);</span>

    <span class="cm">/* GumCpuContext.pc + sp */</span>

    <span class="c1">// We are going to store the PC and SP here. The PC is set to</span>
    <span class="c1">// zero, for the SP, we have to calculate the original SP</span>
    <span class="c1">// before we stored all of this context information. Note we</span>
    <span class="c1">// use the zero register here (a special register in AArch64</span>
    <span class="c1">// which always has the value 0).</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_XZR</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_add_reg_reg_imm</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X1</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">GUM_RED_ZONE_SIZE</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_X1</span><span class="p">);</span>

    <span class="n">immediate_for_sp</span> <span class="o">+=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">GumCpuContext</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Store the Arithmetic Logic Unit flags into X15. Whilst it might</span>
  <span class="c1">// appear that the above add instruction used to calculate the</span>
  <span class="c1">// original stack pointer may have changed the flags, AArch64 has</span>
  <span class="c1">// an ADD instruction which doesn't modify the condition flags</span>
  <span class="c1">// and an ADDS instruction which does.</span>
  <span class="n">gum_arm64_writer_put_instruction</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">mrs_x15_nzcv</span><span class="p">);</span>

  <span class="cm">/* conveniently point X20 at the beginning of the saved
     registers */</span>
  <span class="c1">// X20 is used later by functions such as</span>
  <span class="c1">// gum_exec_ctx_load_real_register_from_full_frame_into() to emit</span>
  <span class="c1">// code which references the saved frame.</span>
  <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">);</span>

  <span class="cm">/* padding + status */</span>
  <span class="c1">// This pushes the flags to ensure that they can be restored</span>
  <span class="c1">// correctly after executing inside of Stalker.</span>
  <span class="n">gum_arm64_writer_put_push_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
  <span class="n">immediate_for_sp</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>

  <span class="c1">// We saved our LR into X19 on entry so that we could branch back</span>
  <span class="c1">// to the instrumented code once this helper has run. Although</span>
  <span class="c1">// the instrumented code called us, we restored LR to its previous</span>
  <span class="c1">// value before the helper was called (the app code). Although the</span>
  <span class="c1">// LR is not callee-saved (e.g. it is not our responsibility to</span>
  <span class="c1">// save and restore it on return, but rather that of our caller),</span>
  <span class="c1">// it is done here to minimize the code size of the inline stub in</span>
  <span class="c1">// the instrumented block.</span>
  <span class="n">gum_arm64_writer_put_br_reg_no_auth</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now let’s look at the epilogue:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_write_epilog_helper</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                                  <span class="n">GumPrologType</span> <span class="n">type</span><span class="p">,</span>
                                  <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// This instruction is used to restore the value of X15 back into</span>
  <span class="c1">// the ALU flags.</span>
  <span class="k">const</span> <span class="n">guint32</span> <span class="n">msr_nzcv_x15</span> <span class="o">=</span> <span class="mh">0xd51b420f</span><span class="p">;</span>

  <span class="cm">/* padding + status */</span>
  <span class="c1">// Note that we don't restore the flags yet, since we must wait</span>
  <span class="c1">// until we have finished all operations (e.g. additions,</span>
  <span class="c1">// subtractions etc) which may modify the flags. However, we</span>
  <span class="c1">// must do so before we restore X15 back to its original value.</span>
  <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_MINIMAL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Save the LR in X19 so we can return back to our caller in the</span>
    <span class="c1">// instrumented block. Note that we must restore the link</span>
    <span class="c1">// register X30 back to its original value (the block in the app</span>
    <span class="c1">// code) before we return. This is carried out below. Recall our</span>
    <span class="c1">// value of X19 is saved to the stack by the inline prolog</span>
    <span class="c1">// itself and restored by the inline prolog to which we are</span>
    <span class="c1">// returning. So we can continue to use it as scratch space</span>
    <span class="c1">// here.</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X19</span><span class="p">,</span> <span class="n">ARM64_REG_LR</span><span class="p">);</span>

    <span class="cm">/* restore status */</span>
    <span class="c1">// We have completed all of our instructions which may alter the</span>
    <span class="c1">// flags.</span>
    <span class="n">gum_arm64_writer_put_instruction</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">msr_nzcv_x15</span><span class="p">);</span>

    <span class="c1">// Restore all of the registers we saved in the context. We</span>
    <span class="c1">// pushed X30 earlier as padding, but we will</span>
    <span class="c1">// pop it back there before we pop the actual pushed value</span>
    <span class="c1">// of X30 immediately after.</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_X1</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X2</span><span class="p">,</span> <span class="n">ARM64_REG_X3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X4</span><span class="p">,</span> <span class="n">ARM64_REG_X5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X6</span><span class="p">,</span> <span class="n">ARM64_REG_X7</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X8</span><span class="p">,</span> <span class="n">ARM64_REG_X9</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X10</span><span class="p">,</span> <span class="n">ARM64_REG_X11</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X12</span><span class="p">,</span> <span class="n">ARM64_REG_X13</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X16</span><span class="p">,</span> <span class="n">ARM64_REG_X17</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X18</span><span class="p">,</span> <span class="n">ARM64_REG_X30</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X29</span><span class="p">,</span> <span class="n">ARM64_REG_X30</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q0</span><span class="p">,</span> <span class="n">ARM64_REG_Q1</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q2</span><span class="p">,</span> <span class="n">ARM64_REG_Q3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q4</span><span class="p">,</span> <span class="n">ARM64_REG_Q5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q6</span><span class="p">,</span> <span class="n">ARM64_REG_Q7</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">GUM_PROLOG_FULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="cm">/* GumCpuContext.pc + sp */</span>
    <span class="c1">// We stored the stack pointer and PC in the stack, but we don't</span>
    <span class="c1">// want to restore the PC back to the user code, and our stack</span>
    <span class="c1">// pointer should be naturally restored as all of the data</span>
    <span class="c1">// pushed onto it are popped back off.</span>
    <span class="n">gum_arm64_writer_put_add_reg_reg_imm</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

    <span class="cm">/* restore status */</span>
    <span class="c1">// Again, we have finished any flag affecting operations now that the</span>
    <span class="c1">// above addition has been completed.</span>
    <span class="n">gum_arm64_writer_put_instruction</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">msr_nzcv_x15</span><span class="p">);</span>

    <span class="cm">/* GumCpuContext.x[29] + fp + lr + padding */</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">ARM64_REG_X1</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X2</span><span class="p">,</span> <span class="n">ARM64_REG_X3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X4</span><span class="p">,</span> <span class="n">ARM64_REG_X5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X6</span><span class="p">,</span> <span class="n">ARM64_REG_X7</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X8</span><span class="p">,</span> <span class="n">ARM64_REG_X9</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X10</span><span class="p">,</span> <span class="n">ARM64_REG_X11</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X12</span><span class="p">,</span> <span class="n">ARM64_REG_X13</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X14</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X16</span><span class="p">,</span> <span class="n">ARM64_REG_X17</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X18</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_X21</span><span class="p">);</span>

    <span class="c1">// Recall that X19 and X20 are actually restored by the epilog</span>
    <span class="c1">// itself since X19 is used as scratch space during the</span>
    <span class="c1">// prolog/epilog helpers and X20 is repurposed by the prolog as</span>
    <span class="c1">// a pointer to the context structure. If we have a full prolog</span>
    <span class="c1">// then this means that it was so that we could enter a callout</span>
    <span class="c1">// which allows the Stalker end user to inspect and modify all</span>
    <span class="c1">// of the registers. This means that any changes to the</span>
    <span class="c1">// registers in the context structure above must be reflected</span>
    <span class="c1">// at runtime. Thus since these values are restored from</span>
    <span class="c1">// higher up the stack by the epilog, we must overwrite their</span>
    <span class="c1">// values there with those from the context structure.</span>
    <span class="n">gum_arm64_writer_put_stp_reg_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">,</span>
        <span class="n">ARM64_REG_X20</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">32</span><span class="p">),</span>
        <span class="n">GUM_INDEX_SIGNED_OFFSET</span><span class="p">);</span>

    <span class="c1">// Save the LR in X19 so we can return back to our caller in the</span>
    <span class="c1">// instrumented code. Note that we must restore the link</span>
    <span class="c1">// register X30 back to its original value before we return.</span>
    <span class="c1">// This is carried out below. Recall our value of X19 is saved</span>
    <span class="c1">// to the stack by the inline prolog itself and restored by the</span>
    <span class="c1">// inline epilogue to which we are returning.</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X19</span><span class="p">,</span> <span class="n">ARM64_REG_LR</span><span class="p">);</span>

    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X22</span><span class="p">,</span> <span class="n">ARM64_REG_X23</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X24</span><span class="p">,</span> <span class="n">ARM64_REG_X25</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X26</span><span class="p">,</span> <span class="n">ARM64_REG_X27</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X28</span><span class="p">,</span> <span class="n">ARM64_REG_X29</span><span class="p">);</span>

    <span class="c1">// Recall that X15 was also pushed as padding alongside X30 when</span>
    <span class="c1">// building the prolog. However, the Stalker end user can modify</span>
    <span class="c1">// the context and hence the value of X15. However this would</span>
    <span class="c1">// not affect the duplicate stashed here as padding and hence</span>
    <span class="c1">// X15 would be clobbered. Therefore we copy the now restored</span>
    <span class="c1">// value of X15 to the location where this copy was stored for</span>
    <span class="c1">// padding before restoring both registers from the stack.</span>
    <span class="n">gum_arm64_writer_put_str_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X15</span><span class="p">,</span> <span class="n">ARM64_REG_SP</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_X30</span><span class="p">,</span> <span class="n">ARM64_REG_X15</span><span class="p">);</span>

    <span class="cm">/* GumCpuContext.q[128] */</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q0</span><span class="p">,</span> <span class="n">ARM64_REG_Q1</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q2</span><span class="p">,</span> <span class="n">ARM64_REG_Q3</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q4</span><span class="p">,</span> <span class="n">ARM64_REG_Q5</span><span class="p">);</span>
    <span class="n">gum_arm64_writer_put_pop_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">ARM64_REG_Q6</span><span class="p">,</span> <span class="n">ARM64_REG_Q7</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Now we can return back to to our caller (the inline part of the</span>
  <span class="c1">// epilogue) with the LR still set to the original value of the</span>
  <span class="c1">// app code.</span>
  <span class="n">gum_arm64_writer_put_br_reg_no_auth</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X19</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This is all quite complicated. Partly this is because we have only a single
register to use as scratch space, partly because we want to keep the prologue
and epilogue code stored inline in the instrumented block to a bare minimum, and
partly because our context values can be changed by callouts and the like. But
hopefully it all now makes sense.</p>

<h2 id="readingwriting-context">Reading/Writing Context</h2>

<p>Now that we have our context saved, whether it was a full context, or just the
minimal one, Stalker may need to read registers from the context to see what
state of the application code was. For example to find the address which a
branch or return instruction was going to branch to so that we can instrument
the block.</p>

<p>When Stalker writes the prologue and epilogue code, it does so by calling
<code class="language-plaintext highlighter-rouge">gum_exec_block_open_prolog()</code> and <code class="language-plaintext highlighter-rouge">gum_exec_block_close_prolog()</code>. These store
the type of prologue which has been written in <code class="language-plaintext highlighter-rouge">gc-&gt;opened_prolog</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_block_open_prolog</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">,</span>
                            <span class="n">GumPrologType</span> <span class="n">type</span><span class="p">,</span>
                            <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">&gt;=</span> <span class="n">type</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="cm">/* We don't want to handle this case for performance reasons */</span>
  <span class="n">g_assert</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">==</span> <span class="n">GUM_PROLOG_NONE</span><span class="p">);</span>

  <span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

  <span class="n">gum_exec_ctx_write_prolog</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">code_writer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_block_close_prolog</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">,</span>
                             <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">==</span> <span class="n">GUM_PROLOG_NONE</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">gum_exec_ctx_write_epilog</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span><span class="p">,</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">code_writer</span><span class="p">);</span>

  <span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">=</span> <span class="n">GUM_PROLOG_NONE</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Therefore when we want to read a register, this can be achieved with the single
function <code class="language-plaintext highlighter-rouge">gum_exec_ctx_load_real_register_into()</code>. This determines which kind of
prologue is in use and calls the relevant routine accordingly. Note that these
routines don’t actually read the registers, they emit code which reads them.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_load_real_register_into</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                                      <span class="n">arm64_reg</span> <span class="n">target_register</span><span class="p">,</span>
                                      <span class="n">arm64_reg</span> <span class="n">source_register</span><span class="p">,</span>
                                      <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">==</span> <span class="n">GUM_PROLOG_MINIMAL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_exec_ctx_load_real_register_from_minimal_frame_into</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">source_register</span><span class="p">,</span> <span class="n">gc</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">==</span> <span class="n">GUM_PROLOG_FULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_exec_ctx_load_real_register_from_full_frame_into</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">source_register</span><span class="p">,</span> <span class="n">gc</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">g_assert_not_reached</span> <span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>Reading registers from the full frame is actually the simplest. We can see the
code closely matches the structure used to pass the context to callouts etc.
Remember that in each case register <code class="language-plaintext highlighter-rouge">X20</code> points to the base of the context
structure.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="n">GumArm64CpuContext</span> <span class="n">GumCpuContext</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_GumArm64CpuContext</span>
<span class="p">{</span>
  <span class="n">guint64</span> <span class="n">pc</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">sp</span><span class="p">;</span>

  <span class="n">guint64</span> <span class="n">x</span><span class="p">[</span><span class="mi">29</span><span class="p">];</span>
  <span class="n">guint64</span> <span class="n">fp</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">lr</span><span class="p">;</span>
  <span class="n">guint8</span> <span class="n">q</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_load_real_register_from_full_frame_into</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
    <span class="n">arm64_reg</span> <span class="n">target_register</span><span class="p">,</span>
    <span class="n">arm64_reg</span> <span class="n">source_register</span><span class="p">,</span>
    <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">;</span>

  <span class="n">cw</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">code_writer</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">&gt;=</span> <span class="n">ARM64_REG_X0</span> <span class="o">&amp;&amp;</span>
      <span class="n">source_register</span> <span class="o">&lt;=</span> <span class="n">ARM64_REG_X28</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="n">G_STRUCT_OFFSET</span> <span class="p">(</span><span class="n">GumCpuContext</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">((</span><span class="n">source_register</span> <span class="o">-</span> <span class="n">ARM64_REG_X0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X29</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="n">G_STRUCT_OFFSET</span> <span class="p">(</span><span class="n">GumCpuContext</span><span class="p">,</span> <span class="n">fp</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X30</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="n">G_STRUCT_OFFSET</span> <span class="p">(</span><span class="n">GumCpuContext</span><span class="p">,</span> <span class="n">lr</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">source_register</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Reading from the minimal context is actually a little harder. <code class="language-plaintext highlighter-rouge">X0</code> through <code class="language-plaintext highlighter-rouge">X18</code>
are simple, they are stored in the context block. After <code class="language-plaintext highlighter-rouge">X18</code> is 8 bytes padding
(to make a total of 10 pairs of registers) followed by <code class="language-plaintext highlighter-rouge">X29</code> and <code class="language-plaintext highlighter-rouge">X30</code>. This
makes a total of 11 pairs of registers. Immediately following this is the
NEON/floating point registers (totaling 128 bytes). Finally <code class="language-plaintext highlighter-rouge">X19</code> and <code class="language-plaintext highlighter-rouge">X20</code>, are
stored above this as they are restored by the inline epilogue code written by
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_write_epilog()</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_load_real_register_from_minimal_frame_into</span> <span class="p">(</span>
    <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
    <span class="n">arm64_reg</span> <span class="n">target_register</span><span class="p">,</span>
    <span class="n">arm64_reg</span> <span class="n">source_register</span><span class="p">,</span>
    <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span><span class="p">;</span>

  <span class="n">cw</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">code_writer</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">&gt;=</span> <span class="n">ARM64_REG_X0</span> <span class="o">&amp;&amp;</span>
      <span class="n">source_register</span> <span class="o">&lt;=</span> <span class="n">ARM64_REG_X18</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="p">(</span><span class="n">source_register</span> <span class="o">-</span> <span class="n">ARM64_REG_X0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X19</span> <span class="o">||</span>
      <span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X20</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">((</span><span class="n">source_register</span> <span class="o">-</span> <span class="n">ARM64_REG_X19</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X29</span> <span class="o">||</span>
      <span class="n">source_register</span> <span class="o">==</span> <span class="n">ARM64_REG_X30</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">ARM64_REG_X20</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">source_register</span> <span class="o">-</span> <span class="n">ARM64_REG_X29</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">gum_arm64_writer_put_mov_reg_reg</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
        <span class="n">target_register</span><span class="p">,</span> <span class="n">source_register</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h2 id="control-flow">Control flow</h2>

<p>Execution of Stalker begins at one of 3 entry points:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">_gum_stalker_do_follow_me()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_stalker_infect()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code></li>
</ul>

<p>The first two we have already covered, these initialize the Stalker engine and
start instrumenting the first block of execution.
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code> is used to instrument subsequent
blocks. In fact, the main difference between this function and the preceding two
is that the Stalker engine has already been initialized and hence this work
doesn’t need to be repeated. All three call <code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> to
generate the instrumented block.</p>

<p>We covered <code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> previously in our section on
transformers. It calls the transformed implementation in use, which by default
calls <code class="language-plaintext highlighter-rouge">gum_stalker_iterator_next()</code> which calls the relocator using
<code class="language-plaintext highlighter-rouge">gum_arm64_relocator_read_one()</code> to read the next relocated instruction. Then it
calls <code class="language-plaintext highlighter-rouge">gum_stalker_iterator_keep()</code> to generate the instrumented copy. It does
this in a loop until <code class="language-plaintext highlighter-rouge">gum_stalker_iterator_next()</code> returns <code class="language-plaintext highlighter-rouge">FALSE</code> as it has
reached the end of the block.</p>

<p>Most of the time <code class="language-plaintext highlighter-rouge">gum_stalker_iterator_keep()</code> will simply call
<code class="language-plaintext highlighter-rouge">gum_arm64_relocator_write_one()</code> to emit the relocated instruction as is.
However, if the instruction is a branch or return instruction it will call
<code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_branch_insn()</code> or
<code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_ret_insn()</code> respectively. These two virtualization
functions which we will cover in more detail later, emit code to transfer
control back into <code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code> via an entry gate
ready to process the next block (unless there is an optimization where we can
bypass Stalker and go direct to the next instrumented block, or we are entering
into an excluded range).</p>

<h2 id="gates">Gates</h2>

<p>Entry gates are generated by macro, one for each of the different instruction
types found at the end of a block. When we virtualize each of these types of
instruction, we direct control flow back to the
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code> function via one of these gates. We
can see that the implementation of the gate is quite simple, it updates a
counter of how many times it has been called and passes control to
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code> passing through the parameters it
was called with, the <code class="language-plaintext highlighter-rouge">GumExecCtx</code> and the <code class="language-plaintext highlighter-rouge">start_address</code> of the next block to
be instrumented.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">gboolean</span> <span class="n">counters_enabled</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="k">static</span> <span class="n">guint</span> <span class="n">total_transitions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define GUM_ENTRYGATE(name) \
  gum_exec_ctx_replace_current_block_from_##name
#define GUM_DEFINE_ENTRYGATE(name) \
  static guint total_##name##s = 0; \
  \
  static gpointer GUM_THUNK \
  GUM_ENTRYGATE (name) ( \
      GumExecCtx * ctx, \
      gpointer start_address) \
  { \
    if (counters_enabled) \
      total_##name##s++; \
    \
    return gum_exec_ctx_replace_current_block_with (ctx, \
        start_address); \
  }
#define GUM_PRINT_ENTRYGATE_COUNTER(name) \
  g_printerr ("\t" G_STRINGIFY (name) "s: %u\n", total_##name##s)</span></code></pre></figure>

<p>These counters can be displayed by the following routine. They are only meant to
be used by the test-suite rather than being exposed to the user through the API.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define GUM_PRINT_ENTRYGATE_COUNTER(name) \
  g_printerr ("\t" G_STRINGIFY (name) "s: %u\n", total_##name##s)
</span>
<span class="kt">void</span>
<span class="nf">gum_stalker_dump_counters</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">g_printerr</span> <span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">total_transitions: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_transitions</span><span class="p">);</span>

  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">call_imm</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">call_reg</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">post_call_invoke</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">excluded_call_imm</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">excluded_call_reg</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>

  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_imm</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_reg</span><span class="p">);</span>

  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_cond_cc</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_cond_cbz</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_cond_cbnz</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_cond_tbz</span><span class="p">);</span>
  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_cond_tbnz</span><span class="p">);</span>

  <span class="n">GUM_PRINT_ENTRYGATE_COUNTER</span> <span class="p">(</span><span class="n">jmp_continuation</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h2 id="virtualize-functions">Virtualize functions</h2>

<p>Let’s now look in more detail at the <em>virtualizing</em> we have for replacing the
branch instruction we find at the end of each block. We have four of these
functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_branch_insn()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_ret_insn()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_sysenter_insn()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_linux_sysenter()</code></li>
</ul>

<p>We can see that two of these relate to to syscalls (and in fact, one calls the
other), we will cover these later. Let’s look at the ones for branches and
returns.</p>

<h3 id="gum_exec_block_virtualize_branch_insn">gum_exec_block_virtualize_branch_insn</h3>

<p>This routine first determines whether the destination of the branch comes from
an immediate offset in the instruction, or a register. In the case of the
latter, we don’t extract the value just yet, we only determine which register.
This is referred to as the <code class="language-plaintext highlighter-rouge">target</code>. The next section of the function deals with
branch instructions. This includes both conditional and non-conditional
branches. For conditional targets the destination if the branch is not taken is
referred to as <code class="language-plaintext highlighter-rouge">cond_target</code>, this is set to the address of the next instruction
in the original block.</p>

<p>Likewise <code class="language-plaintext highlighter-rouge">regular_entry_func</code> and <code class="language-plaintext highlighter-rouge">cond_entry_func</code> are used to hold the entry
gates which will be used to handle the branch. The former is used to hold the
gate used for non-conditional branches and <code class="language-plaintext highlighter-rouge">cond_entry_func</code> holds the gate to
be used for a conditional branch (whether it is taken or not).</p>

<p>The function <code class="language-plaintext highlighter-rouge">gum_exec_block_write_jmp_transfer_code()</code> is used to write the
code required to branch to the entry gate. For non-conditional branches this is
simple, we call the function passing the <code class="language-plaintext highlighter-rouge">target</code> and the <code class="language-plaintext highlighter-rouge">regular_entry_func</code>.
For conditional branches things are slightly more complicated. Our output looks
like the following pseudo-code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="n">INVERSE_OF_ORIGINAL_BRANCH</span><span class="p">(</span><span class="n">is_false</span><span class="p">)</span>
  <span class="n">jmp_transfer_code</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">cond_entry_func</span><span class="p">)</span>
<span class="n">is_false</span><span class="o">:</span>
  <span class="n">jmp_transfer_code</span><span class="p">(</span><span class="n">cond_target</span><span class="p">,</span> <span class="n">cond_entry_func</span><span class="p">)</span></code></pre></figure>

<p>Here, we can see that we first write a branch instruction into our instrumented
block, as in our instrumented block, we also need to determine whether we should
take the branch or not. But instead of branching directly to the target, just
like for the non-conditional branches we use
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_jmp_transfer_code()</code> to write code to jump back into
Stalker via the relevant entry gate passing the real address we would have
branched to. Note, however that the branch is inverted from the original (e.g.
<code class="language-plaintext highlighter-rouge">CBZ</code> would be replaced by <code class="language-plaintext highlighter-rouge">CBNZ</code>).</p>

<p>Now, let’s look at how <code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_branch_insn()</code> handles calls.
First we emit code to generate the call event if we are configured to. Next we
check if there are any probes in use. If there are, then we call
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_call_probe_code()</code> to emit the code necessary to call any
registered probe callback. Next, we check if the call is to an excluded range
(note that we can only do this if the call is to an immediate address), if it is
then we emit the instruction as is. But we follow this by using
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_jmp_transfer_code()</code> as we did when handling branches to
emit code to call back into Stalker right after to instrument the block at the
return address. Note that here we use the <code class="language-plaintext highlighter-rouge">excluded_call_imm</code> entry gate.</p>

<p>Finally, if it is just a normal call expression, then we use the function
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_call_invoke_code()</code> to emit the code to handle the call.
This function is pretty complicated as a result of all of the optimization for
backpatching, so we will only look at the basics.</p>

<p>Remember earlier that in <code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_branch_insn()</code>, we could
only check if our call was to an excluded range if the target was specified in
an immediate? Well if the target was specified in a register, then here we emit
code to check whether the target is in an excluded range. This is done by
loading the target register using
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_write_push_branch_target_address()</code> (which in turn calls
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_load_real_register_into()</code> which we covered ealier to read the
context) and emitting code to call
<code class="language-plaintext highlighter-rouge">gum_exec_block_check_address_for_exclusion()</code> whose implementation is quite
self-explanatory. If it is excluded then a branch is taken and similar code to
that described when handling excluded immediate calls discussed above is used.</p>

<p>Next we emit code to call the entry gate and generate the instrumented block of
the callee. Then call the helper <code class="language-plaintext highlighter-rouge">last_stack_push</code> to add our <code class="language-plaintext highlighter-rouge">GumExecFrame</code> to
our context containing the original and instrumented block address. The real and
instrumented code addresses are read from the current cursor positions of the
GeneratorContext and CodeWriter respectively, and we then generate the required
landing pad for the return address (this is the optimization we covered
earlier, we can jump straight to this block when executing the virtualized
return statement rather than re-entering Stalker). Lastly we use
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_exec_generated_code()</code> to emit code to branch to the
instrumented callee.</p>

<h3 id="gum_exec_block_virtualize_ret_insn">gum_exec_block_virtualize_ret_insn</h3>

<p>After looking at the virtualization of call instructions, you will be pleased to
know that this one is relatively simple! If configured, this function calls
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_ret_event_code()</code> to generate an event for the return
statement. Then it calls <code class="language-plaintext highlighter-rouge">gum_exec_block_write_ret_transfer_code()</code> to generate
the code required to handle the return instruction. This one is simple too, it
emits code to call the <code class="language-plaintext highlighter-rouge">last_stack_pop_and_go</code> helper we covered earlier.</p>

<h2 id="emitting-events">Emitting events</h2>

<p>Events are one of the key outputs of the Stalker engine. They are emitted by the
following functions. Their implementation again is quite self-explanatory:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_ctx_emit_call_event()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_ctx_emit_ret_event()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_ctx_emit_exec_event()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_exec_ctx_emit_block_event()</code></li>
</ul>

<p>One thing to note with each of these functions, however, is that they all call
<code class="language-plaintext highlighter-rouge">gum_exec_block_write_unfollow_check_code()</code> to generate code for checking if
Stalker is to stop following the thread. We’ll have a look at this in more
detail next.</p>

<h2 id="unfollow-and-tidy-up">Unfollow and tidy up</h2>

<p>If we look at the function which generates the instrumented code to check if we
are being asked to unfollow, we can see it cause the thread to call
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_maybe_unfollow()</code> passing the address of the next instruction to
be instrumented. We can see that if the state has been set to stop following,
then we simply branch back to the original code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_block_write_unfollow_check_code</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">,</span>
                                          <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">,</span>
                                          <span class="n">GumCodeContext</span> <span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">;</span>
  <span class="n">GumArm64Writer</span> <span class="o">*</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">code_writer</span><span class="p">;</span>
  <span class="n">gconstpointer</span> <span class="n">beach</span> <span class="o">=</span> <span class="n">cw</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">GumPrologType</span> <span class="n">opened_prolog</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cc</span> <span class="o">!=</span> <span class="n">GUM_CODE_INTERRUPTIBLE</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">gum_arm64_writer_put_call_address_with_arguments</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="n">gum_exec_ctx_maybe_unfollow</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span>
      <span class="n">GUM_ARG_ADDRESS</span><span class="p">,</span> <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="n">ctx</span><span class="p">),</span>
      <span class="n">GUM_ARG_ADDRESS</span><span class="p">,</span> <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">instruction</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">));</span>
  <span class="n">gum_arm64_writer_put_cbz_reg_label</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X0</span><span class="p">,</span> <span class="n">beach</span><span class="p">);</span>

  <span class="n">opened_prolog</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span><span class="p">;</span>
  <span class="n">gum_exec_block_close_prolog</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">gc</span><span class="p">);</span>
  <span class="n">gc</span><span class="o">-&gt;</span><span class="n">opened_prolog</span> <span class="o">=</span> <span class="n">opened_prolog</span><span class="p">;</span>

  <span class="n">gum_arm64_writer_put_ldr_reg_address</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X16</span><span class="p">,</span>
      <span class="n">GUM_ADDRESS</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span><span class="p">));</span>
  <span class="n">gum_arm64_writer_put_ldr_reg_reg_offset</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span>
      <span class="n">ARM64_REG_X17</span><span class="p">,</span> <span class="n">ARM64_REG_X16</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">gum_arm64_writer_put_br_reg_no_auth</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">ARM64_REG_X17</span><span class="p">);</span>

  <span class="n">gum_arm64_writer_put_label</span> <span class="p">(</span><span class="n">cw</span><span class="p">,</span> <span class="n">beach</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gboolean</span>
<span class="nf">gum_exec_ctx_maybe_unfollow</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                             <span class="n">gpointer</span> <span class="n">resume_at</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g_atomic_int_get</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">!=</span>
      <span class="n">GUM_EXEC_CTX_UNFOLLOW_PENDING</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pending_calls</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

  <span class="n">gum_exec_ctx_unfollow</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">resume_at</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_exec_ctx_unfollow</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                       <span class="n">gpointer</span> <span class="n">resume_at</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span> <span class="o">=</span> <span class="n">resume_at</span><span class="p">;</span>

  <span class="n">gum_tls_key_set_value</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">stalker</span><span class="o">-&gt;</span><span class="n">exec_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">destroy_pending_since</span> <span class="o">=</span> <span class="n">g_get_monotonic_time</span> <span class="p">();</span>
  <span class="n">g_atomic_int_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">GUM_EXEC_CTX_DESTROY_PENDING</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>A quick note about pending calls. If we have a call to an excluded range, then
we emit the original call in the instrumented code followed by a call back to
Stalker. Whilst the thread is running in the excluded range, however, we cannot
control the instruction pointer until it returns. We therefore need to simply
keep track of these and wait for the thread to exit the excluded range.</p>

<p>Now we can see how a running thread gracefully goes back to running normal
uninstrumented code, let’s see how we stop stalking in the first place. We have
two possible ways to stop stalking:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">gum_stalker_unfollow_me()</code></li>
  <li><code class="language-plaintext highlighter-rouge">gum_stalker_unfollow()</code></li>
</ul>

<p>The first is quite simple, we set the state to stop following. Then call
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_maybe_unfollow()</code> to attempt to stop the current thread from being
followed, and then dispose of the Stalker context.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">gum_stalker_unfollow_me</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">;</span>

  <span class="n">ctx</span> <span class="o">=</span> <span class="n">gum_stalker_get_exec_ctx</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">g_atomic_int_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">GUM_EXEC_CTX_UNFOLLOW_PENDING</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gum_exec_ctx_maybe_unfollow</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">g_assert</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">unfollow_called_while_still_following</span><span class="p">);</span>

  <span class="n">gum_stalker_destroy_exec_ctx</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>We notice here that we pass <code class="language-plaintext highlighter-rouge">NULL</code> as the address to
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_maybe_unfollow()</code> which may seem odd, but we can see that in this
instance it isn’t used as when we instrument a block (remember
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_replace_current_block_with()</code> is where the entry gates direct us
to instrument subsequent blocks) we check to see if we are about to call
<code class="language-plaintext highlighter-rouge">gum_unfollow_me()</code>, and if so then we return the original block from the
function rather than the address of the instrumented block generated by
<code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code>. Therefore we can see that this is a special
case and this function isn’t stalked. We simply jump to the real function so at
this point we have stopped stalking the thread forever. This handling differs
from excluded ranges as for those we retain the original call instruction in an
instrumented block, but then follow it with a call back into Stalker. In this
case, we are just vectoring back to an original uninstrumented block:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">gpointer</span> <span class="n">gum_unfollow_me_address</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gum_stalker_class_init</span> <span class="p">(</span><span class="n">GumStalkerClass</span> <span class="o">*</span> <span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="n">gum_unfollow_me_address</span> <span class="o">=</span> <span class="n">gum_strip_code_pointer</span> <span class="p">(</span>
      <span class="n">gum_stalker_unfollow_me</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gpointer</span>
<span class="nf">gum_exec_ctx_replace_current_block_with</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                                         <span class="n">gpointer</span> <span class="n">start_address</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">start_address</span> <span class="o">==</span> <span class="n">gum_unfollow_me_address</span> <span class="o">||</span>
      <span class="n">start_address</span> <span class="o">==</span> <span class="n">gum_deactivate_address</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">unfollow_called_while_still_following</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span> <span class="o">=</span> <span class="n">start_address</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>

  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">current_block</span> <span class="o">=</span> <span class="n">gum_exec_ctx_obtain_block_for</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span>
        <span class="n">start_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span><span class="p">);</span>

    <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">resume_at</span><span class="p">;</span>

  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s look at <code class="language-plaintext highlighter-rouge">gum_stalker_unfollow()</code> now:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">gum_stalker_unfollow</span> <span class="p">(</span><span class="n">GumStalker</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                      <span class="n">GumThreadId</span> <span class="n">thread_id</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">thread_id</span> <span class="o">==</span> <span class="n">gum_process_get_current_thread_id</span> <span class="p">())</span>
  <span class="p">{</span>
    <span class="n">gum_stalker_unfollow_me</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">GSList</span> <span class="o">*</span> <span class="n">cur</span><span class="p">;</span>

    <span class="n">GUM_STALKER_LOCK</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">contexts</span><span class="p">;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span> <span class="o">=</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span><span class="p">)</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">thread_id</span> <span class="o">==</span> <span class="n">thread_id</span> <span class="o">&amp;&amp;</span>
          <span class="n">g_atomic_int_compare_and_exchange</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
              <span class="n">GUM_EXEC_CTX_ACTIVE</span><span class="p">,</span>
              <span class="n">GUM_EXEC_CTX_UNFOLLOW_PENDING</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">GUM_STALKER_UNLOCK</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gum_exec_ctx_has_executed</span> <span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
        <span class="p">{</span>
          <span class="n">GumDisinfectContext</span> <span class="n">dc</span><span class="p">;</span>

          <span class="n">dc</span><span class="p">.</span><span class="n">exec_ctx</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
          <span class="n">dc</span><span class="p">.</span><span class="n">success</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

          <span class="n">gum_process_modify_thread</span> <span class="p">(</span><span class="n">thread_id</span><span class="p">,</span>
              <span class="n">gum_stalker_disinfect</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc</span><span class="p">);</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">dc</span><span class="p">.</span><span class="n">success</span><span class="p">)</span>
            <span class="n">gum_stalker_destroy_exec_ctx</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">GUM_STALKER_UNLOCK</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This function looks through the list of contexts looking for the one for the
requested thread. Again, it sets the state of the context to
<code class="language-plaintext highlighter-rouge">GUM_EXEC_CTX_UNFOLLOW_PENDING</code>. If the thread has already run, we must wait for
it to check this flag and return to normal execution. However, if it has not run
(perhaps it was in a blocking syscall when we asked to follow it and never got
infected in the first instance) then we can <em>disinfect</em> it ourselves by calling
<code class="language-plaintext highlighter-rouge">gum_process_modify_thread()</code> to modify the thread context (this function was
described in detail earlier) and using <code class="language-plaintext highlighter-rouge">gum_stalker_disinfect()</code> as our callback
to perform the changes. This simply checks to see if the program counter was set
to point to the <code class="language-plaintext highlighter-rouge">infect_thunk</code> and resets the program pointer back to its
original value. The <code class="language-plaintext highlighter-rouge">infect_thunk</code> is created by <code class="language-plaintext highlighter-rouge">gum_stalker_infect()</code> which is
the callback used by <code class="language-plaintext highlighter-rouge">gum_stalker_follow()</code> to modify the context. Recall that
whilst some of the setup can be carried out on behalf of the target thread, some
has to be done in the context of the target thread itself (in particular setting
variables in thread-local storage). Well, it is the <code class="language-plaintext highlighter-rouge">infect_thunk</code> which
contains that code.</p>

<h2 id="miscellaneous">Miscellaneous</h2>

<p>Hopefully we have now covered the most important aspects of Stalker and have
provided a good background on how it works. We do have a few other observations
though, which may be of interest.</p>

<h3 id="exclusive-store">Exclusive Store</h3>

<p>The AArch64 architecture has support for <a href="https://static.docs.arm.com/100934/0100/armv8_a_synchronization_primitives_100934_0100_en.pdf">exclusive load/store
instructions</a>.
These instructions are intended to be used for synchronization. If an exclusive
load is performed from a given address, then later attempts an exclusive store
to the same location, then the CPU is able to detect any other stores (exclusive
or otherwise) to the same location in the intervening period and the store
fails.</p>

<p>Obviously, these types of primitives are likely to be used for constructs such
as mutexes and semaphores. Multiple threads may attempt to load the current
count of the semaphore, test whether is it already full, then increment and
store the new value back to take the semaphore. These exclusive operations are
ideal for just such a scenario. Consider though what would happen if multiple
threads are competing for the same resource. If one of those threads were being
traced by Stalker, it would always lose the race. Also these instructions are
easily disturbed by other kinds of CPU operations and so if we do something
complex like emit an event between a load and a store we are going to cause it
to fail every time, and end up looping indefinitely. Stalker, however, deals
with such a scenario:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">gboolean</span>
<span class="nf">gum_stalker_iterator_next</span> <span class="p">(</span><span class="n">GumStalkerIterator</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">cs_insn</span> <span class="o">**</span> <span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>

  <span class="p">...</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">instruction</span><span class="o">-&gt;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STXR</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STXP</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STXRB</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STXRH</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STLXR</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STLXP</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STLXRB</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">ARM64_INS_STLXRH</span><span class="p">:</span>
        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">=</span> <span class="n">GUM_INSTRUCTION_OFFSET_NONE</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="nl">default:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">!=</span> <span class="n">GUM_INSTRUCTION_OFFSET_NONE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">=</span> <span class="n">GUM_INSTRUCTION_OFFSET_NONE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">...</span>
  <span class="p">...</span>
<span class="err">}</span>

<span class="kt">void</span>
<span class="nf">gum_stalker_iterator_keep</span> <span class="p">(</span><span class="n">GumStalkerIterator</span> <span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">insn</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDAXR</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDAXP</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDAXRB</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDAXRH</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDXR</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDXP</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDXRB</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">ARM64_INS_LDXRH</span><span class="p">:</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Here, we can see that the iterator records when it sees an exclusive load and
tracks how many instructions have passed since. This is continued for up to four
instructions – as this was determined by empirical testing based on how many
instructions would be needed to load, test, modify and store the value. This is
then used to prevent any instrumentation being emitted which isn’t strictly
necessary:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">((</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">sink_mask</span> <span class="o">&amp;</span> <span class="n">GUM_EXEC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">exclusive_load_offset</span> <span class="o">==</span> <span class="n">GUM_INSTRUCTION_OFFSET_NONE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">gum_exec_block_write_exec_event_code</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span>
        <span class="n">GUM_CODE_INTERRUPTIBLE</span><span class="p">);</span>
  <span class="p">}</span></code></pre></figure>

<h3 id="exhausted-blocks">Exhausted Blocks</h3>

<p>Whilst we check to ensure a minimum amount of space for our current instrumented
block is left in the slab before we start (and allocate a new one if we fall
below this minimum), we cannot predict how long a sequence of instructions we
are likely to encounter in our input block. Nor is it simple to detemine exactly
how many instructions in output we will need to write the necessary
instrumentation (we have possible code for emitting the different types of
event, checking for excluded ranges, virtualizing instructions found at the end
of the block etc.). Also, trying to allow for the instrumented code to be
non-sequential is fraught with difficulty. So the approach taken is to ensure
that each time we read a new instruction from the iterator there is at least
1024 bytes of space in the slab for our output. If it is not the case, then we
store the current address in <code class="language-plaintext highlighter-rouge">continuation_real_address</code> and return <code class="language-plaintext highlighter-rouge">FALSE</code> so
that the iterator ends.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define GUM_EXEC_BLOCK_MIN_SIZE 1024
</span>
<span class="k">static</span> <span class="n">gboolean</span>
<span class="nf">gum_exec_block_is_full</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">guint8</span> <span class="o">*</span> <span class="n">slab_end</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">slab</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">slab_end</span> <span class="o">-</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">code_end</span> <span class="o">&lt;</span> <span class="n">GUM_EXEC_BLOCK_MIN_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gboolean</span>
<span class="nf">gum_stalker_iterator_next</span> <span class="p">(</span><span class="n">GumStalkerIterator</span> <span class="o">*</span> <span class="n">self</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">cs_insn</span> <span class="o">**</span> <span class="n">insn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gum_exec_block_is_full</span> <span class="p">(</span><span class="n">block</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">gc</span><span class="o">-&gt;</span><span class="n">continuation_real_address</span> <span class="o">=</span> <span class="n">instruction</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Our caller <code class="language-plaintext highlighter-rouge">gum_exec_ctx_obtain_block_for()</code> which is walking the iterator to
generate the block then acts exactly as if there was a branch instruction to the
next instruction, essentially terminating the current block and starting the
next one.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">GumExecBlock</span> <span class="o">*</span>
<span class="nf">gum_exec_ctx_obtain_block_for</span> <span class="p">(</span><span class="n">GumExecCtx</span> <span class="o">*</span> <span class="n">ctx</span><span class="p">,</span>
                               <span class="n">gpointer</span> <span class="n">real_address</span><span class="p">,</span>
                               <span class="n">gpointer</span> <span class="o">*</span> <span class="n">code_address_ptr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="p">.</span><span class="n">continuation_real_address</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">GumBranchTarget</span> <span class="n">continue_target</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

    <span class="n">continue_target</span><span class="p">.</span><span class="n">absolute_address</span> <span class="o">=</span> <span class="n">gc</span><span class="p">.</span><span class="n">continuation_real_address</span><span class="p">;</span>
    <span class="n">continue_target</span><span class="p">.</span><span class="n">reg</span> <span class="o">=</span> <span class="n">ARM64_REG_INVALID</span><span class="p">;</span>
    <span class="n">gum_exec_block_write_jmp_transfer_code</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">continue_target</span><span class="p">,</span>
        <span class="n">GUM_ENTRYGATE</span> <span class="p">(</span><span class="n">jmp_continuation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">gc</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>It is as if the following instructions had been encountered in the input right
before the instruction which would have not had sufficient space:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">  B label
label:</code></pre></figure>

<h3 id="syscall-virtualization">Syscall Virtualization</h3>

<p>Syscalls are entry points from user-mode into kernel-mode. It is how
applications ask the kernel carry out operations on its behalf, whether that be
opening files or reading network sockets. On AArch64 systems, this is carried
out using the <code class="language-plaintext highlighter-rouge">SVC</code> instruction, whereas on Intel the instruction is <code class="language-plaintext highlighter-rouge">sysenter</code>.
Hence the terms syscall and sysenter here are used synonymously.</p>

<p>Syscall virtualization is carried out by the following routine. We can see we
only do anything on Linux systems:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">GumVirtualizationRequirements</span>
<span class="nf">gum_exec_block_virtualize_sysenter_insn</span> <span class="p">(</span><span class="n">GumExecBlock</span> <span class="o">*</span> <span class="n">block</span><span class="p">,</span>
                                         <span class="n">GumGeneratorContext</span> <span class="o">*</span> <span class="n">gc</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef HAVE_LINUX
</span>  <span class="k">return</span> <span class="n">gum_exec_block_virtualize_linux_sysenter</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">gc</span><span class="p">);</span>
<span class="cp">#else
</span>  <span class="k">return</span> <span class="n">GUM_REQUIRE_RELOCATION</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span></code></pre></figure>

<p>This is required because of the <code class="language-plaintext highlighter-rouge">clone</code> syscall. This syscall creates a new
process which shares execution context with the parent, such as file handles,
virtual address space, and signal handlers. In essence, this effectively creates
a new thread. But the current thread is being traced by Stalker, and clone is
going to create an exact replica of it. Given that Stalker contexts are on a
per-thread basis, we should not be stalking this new child.</p>

<p>Note that for syscalls in AArch64 the first 8 arguments are passed in registers
<code class="language-plaintext highlighter-rouge">X0</code> through <code class="language-plaintext highlighter-rouge">X7</code> and the syscall number is passed in <code class="language-plaintext highlighter-rouge">X8</code>, additional arguments
are passed on the stack. The return value for the syscall is returned in <code class="language-plaintext highlighter-rouge">X0</code>.
The function <code class="language-plaintext highlighter-rouge">gum_exec_block_virtualize_linux_sysenter()</code> generates the
necessary instrumented code to deal with such a syscall. We will look at the
pseudo code below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="n">x8</span> <span class="o">==</span> <span class="n">__NR_clone</span><span class="o">:</span>
  <span class="n">x0</span> <span class="o">=</span> <span class="n">do_original_syscall</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">x0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>
    <span class="k">goto</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">instruction</span><span class="o">-&gt;</span><span class="n">begin</span>
  <span class="k">return</span> <span class="n">x0</span>
<span class="k">else</span><span class="o">:</span>
  <span class="k">return</span> <span class="n">do_original_syscall</span><span class="p">()</span></code></pre></figure>

<p>We can see that it first checks if we are dealing with a <code class="language-plaintext highlighter-rouge">clone</code> syscall,
otherwise it simply performs the original syscall and that is all (the original
syscall instruction is copied from the original block). Otherwise if it is a
clone syscall, then we again perform the original syscall. At this point, we
have two threads of execution, the syscall determines that each thread will
<a href="http://man7.org/linux/man-pages/man2/clone.2.html">return a different value</a>.
The original thread will receive the child’s PID as its return value, whereas
the child will receive the value of 0.</p>

<p>If we receive a non-zero value, we can simply continue as we were. We want to
continue stalking the thread and allow execution to carry on with the next
instruction. If, however, we receive a return value of 0, then we are in the
child thread. We therefore carry out a branch to the next instruction in the
original block ensuring that the child continues to run without any interruption
from Stalker.</p>

<h3 id="pointer-authentication">Pointer Authentication</h3>

<p>Last of all, we should note that newer versions of iOS have
<a href="https://ivrodriguez.com/pointer-authentication-on-armv8-3/">introduced</a>
<a href="https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf">pointer authentication
codes</a>.
Pointer authentication codes (PACs) make use of unused bits in pointers (the
high bits of virtual addresses are commonly unused as most systems have a
maximum of 48-bits of virtual address space) to store authentication values.
These values are calculated by using the original pointer, a context parameter
(typically the contents of another register) and a cryptographic key. The idea
is that the key cannot be read or written from user-mode, and the resulting
pointer authentication code cannot be guessed without having access to it.</p>

<p>Let’s look at the following fragment of code:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">pacia lr, sp
stp fp, lr, [sp, #-FRAME_SIZE]!
mov fp, sp

...

ldp fp, lr, [sp], #FRAME_SIZE
autia lr, sp
ret lr</code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">pacia</code> instruction combines the values of <code class="language-plaintext highlighter-rouge">LR</code>, <code class="language-plaintext highlighter-rouge">SP</code> and the key to
generate a version of <code class="language-plaintext highlighter-rouge">LR</code> with the authentication code <code class="language-plaintext highlighter-rouge">LR'</code> and stores back
into the <code class="language-plaintext highlighter-rouge">LR</code> register. This value is stored in the stack and later restored at
the end of the function. The <code class="language-plaintext highlighter-rouge">autia</code> instruction validates the value of <code class="language-plaintext highlighter-rouge">LR'</code>.
This is possible since the PAC in the high bits of <code class="language-plaintext highlighter-rouge">LR</code> can be stripped to give
the original <code class="language-plaintext highlighter-rouge">LR</code> value and the pointer authentication code can be regenerated
as it was before using <code class="language-plaintext highlighter-rouge">SP</code> and the key. The result is checked against <code class="language-plaintext highlighter-rouge">LR'</code>. If
the value doesn’t match then the instruction generates a fault. Thus if the
value of <code class="language-plaintext highlighter-rouge">LR</code> stored in the stack is modified, or the stack pointer itself is
corrupted then the validation will fail. This is useful to prevent the building
of ROP chains which require return addresses to be stored in the stack. Since
<code class="language-plaintext highlighter-rouge">LR'</code> is now stored in the stack instead of <code class="language-plaintext highlighter-rouge">LR</code>, valid return addresses cannot
be forged without the key.</p>

<p>Frida needs to take this into account also when generating code. When reading
pointers from registers used by the application (e.g. to determine the
destination of an indirect branch or return), it is necessary to strip these
pointer authentication codes from the address before it is used. This is
achieved using the function <code class="language-plaintext highlighter-rouge">gum_arm64_writer_put_xpaci_reg()</code>.</p>

          





  
  

  
  

  
  

  
  

  
  

  
  

  
  
    <div class="section-nav">
      <div class="left align-right">
          
            
            
            <a href="../hacking/index.html" class="prev">Back</a>
          
      </div>
      <div class="right align-left">
          
            
            
            <a href="../presentations/index.html" class="next">Next</a>
          
      </div>
    </div>
    <div class="clear"></div>
    

        </article>
      </div>

    </div>
  </section>


  <footer>
  <div class="grid">
    <div class="unit whole align-right center-on-mobiles">
      <div class="sponsored-by">
        <h5>Sponsored by:</h5>
        <a href="https://www.nowsecure.com">
          <img src="../../img/nowsecure-logo.png" alt="NowSecure">
        </a>
      </div>
    </div>
  </div>
</footer>

  


  <!-- Google Analytics (http://google.com/analytics) -->
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-46880695-1']);
    _gaq.push(['_setDomainName', 'https://frida.re']); // Multiple sub-domains
    _gaq.push(['_setAllowLinker', true]); // Multiple TLDs
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



</body>
</html>
